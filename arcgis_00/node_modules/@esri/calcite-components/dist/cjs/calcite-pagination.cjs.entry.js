/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.9.2
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-1dfb3582.js');
const loadable = require('./loadable-9fb19dca.js');
const locale = require('./locale-224355d0.js');
const t9n = require('./t9n-347a842b.js');
const observers = require('./observers-4b9a2593.js');
const responsive = require('./responsive-07514287.js');
require('./dom-6b4a1e9b.js');
require('./guid-43338402.js');
require('./resources-e4238f76.js');
require('./key-a13ec672.js');

const CSS = {
  page: "page",
  selected: "is-selected",
  previous: "previous",
  next: "next",
  disabled: "is-disabled",
  ellipsis: "ellipsis",
  ellipsisStart: "ellipsis--start",
  ellipsisEnd: "ellipsis--end",
};
const ICONS = {
  next: "chevronRight",
  previous: "chevronLeft",
};

const paginationCss = ":host{display:flex;writing-mode:horizontal-tb}:host([scale=s]) .previous,:host([scale=s]) .next,:host([scale=s]) .page,:host([scale=s]) .ellipsis{block-size:1.5rem;padding-inline:0.25rem;font-size:var(--calcite-font-size--2);line-height:1rem;min-inline-size:1.5rem}:host([scale=m]) .previous,:host([scale=m]) .next,:host([scale=m]) .page,:host([scale=m]) .ellipsis{block-size:2rem;padding-inline:0.5rem;font-size:var(--calcite-font-size--1);line-height:1rem;min-inline-size:2rem}:host([scale=l]) .previous,:host([scale=l]) .next,:host([scale=l]) .page,:host([scale=l]) .ellipsis{block-size:2.75rem;font-size:var(--calcite-font-size-0);line-height:1.25rem;min-inline-size:2.75rem}:host([scale=l]) .previous,:host([scale=l]) .next{padding-inline:0.625rem}:host([scale=l]) .page,:host([scale=l]) .ellipsis{padding-inline:0.75rem}:host button{outline-color:transparent}:host button:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-ui-brand));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-ui-focus-offset-invert),\n                1\n              )\n            )\n          )}.previous,.next,.page,.ellipsis{margin:0px;box-sizing:border-box;display:flex;align-items:center;justify-content:center;border-style:none;--tw-border-opacity:0;background-color:transparent;padding:0px;vertical-align:baseline;font-family:inherit;font-size:var(--calcite-font-size-0);line-height:1.25rem;color:var(--calcite-ui-text-3)}.previous,.next,.page{cursor:pointer;border-block:2px solid transparent}.previous:hover,.next:hover,.page:hover{color:var(--calcite-ui-text-1);transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}.page:hover{border-block-end-color:var(--calcite-ui-border-2)}.page.is-selected{font-weight:var(--calcite-font-weight-medium);color:var(--calcite-ui-text-1);border-block-end-color:var(--calcite-ui-brand)}.previous:hover,.next:hover{background-color:var(--calcite-ui-foreground-2);color:var(--calcite-ui-brand)}.previous:active,.next:active{background-color:var(--calcite-ui-foreground-3)}.previous.is-disabled,.next.is-disabled{pointer-events:none;background-color:transparent}.previous.is-disabled>calcite-icon,.next.is-disabled>calcite-icon{opacity:var(--calcite-ui-opacity-disabled)}:host([hidden]){display:none}[hidden]{display:none}";

const firstAndLastPageCount = 2;
const ellipsisCount = 2;
const maxItemBreakpoints = {
  large: 11,
  medium: 9,
  small: 7,
  xsmall: 5,
};
const Pagination = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.calcitePaginationChange = index.createEvent(this, "calcitePaginationChange", 6);
    this.resizeObserver = observers.createObserver("resize", (entries) => entries.forEach(this.resizeHandler));
    this.resizeHandler = ({ contentRect: { width } }) => this.setMaxItemsToBreakpoint(width);
    this.previousClicked = async () => {
      await this.previousPage();
      this.emitUpdate();
    };
    this.nextClicked = async () => {
      await this.nextPage();
      this.emitUpdate();
    };
    this.handlePageClick = (event) => {
      const target = event.target;
      this.startItem = parseInt(target.value, 10);
      this.emitUpdate();
    };
    this.groupSeparator = false;
    this.messages = undefined;
    this.messageOverrides = undefined;
    this.numberingSystem = undefined;
    this.pageSize = 20;
    this.scale = "m";
    this.startItem = 1;
    this.totalItems = 0;
    this.defaultMessages = undefined;
    this.effectiveLocale = "";
    this.maxItems = maxItemBreakpoints.xsmall;
    this.totalPages = undefined;
  }
  onMessagesChange() {
    /* wired up by t9n util */
  }
  handleTotalPages() {
    this.totalPages = this.totalItems / this.pageSize;
  }
  effectiveLocaleChange() {
    t9n.updateMessages(this, this.effectiveLocale);
  }
  effectiveLocaleWatcher() {
    locale.numberStringFormatter.numberFormatOptions = {
      locale: this.effectiveLocale,
      numberingSystem: this.numberingSystem,
      useGrouping: this.groupSeparator,
    };
  }
  // --------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  // --------------------------------------------------------------------------
  connectedCallback() {
    locale.connectLocalized(this);
    t9n.connectMessages(this);
    this.resizeObserver?.observe(this.el);
  }
  async componentWillLoad() {
    const [, breakpoints] = await Promise.all([t9n.setUpMessages(this), responsive.getBreakpoints()]);
    this.breakpoints = breakpoints;
    loadable.setUpLoadableComponent(this);
    this.handleTotalPages();
  }
  componentDidLoad() {
    loadable.setComponentLoaded(this);
    this.setMaxItemsToBreakpoint(this.el.clientWidth);
  }
  disconnectedCallback() {
    locale.disconnectLocalized(this);
    t9n.disconnectMessages(this);
    this.resizeObserver?.disconnect();
  }
  // --------------------------------------------------------------------------
  //
  //  Public Methods
  //
  // --------------------------------------------------------------------------
  /** Sets focus on the component's first focusable element. */
  async setFocus() {
    await loadable.componentFocusable(this);
    this.el.focus();
  }
  /** Go to the next page of results. */
  async nextPage() {
    this.startItem = Math.min(this.getLastStart(), this.startItem + this.pageSize);
  }
  /** Go to the previous page of results. */
  async previousPage() {
    this.startItem = Math.max(1, this.startItem - this.pageSize);
  }
  // --------------------------------------------------------------------------
  //
  //  Private Methods
  //
  // --------------------------------------------------------------------------
  setMaxItemsToBreakpoint(width) {
    const { breakpoints } = this;
    if (!breakpoints || !width) {
      return;
    }
    if (width >= breakpoints.width.medium) {
      this.maxItems = maxItemBreakpoints.large;
      return;
    }
    if (width >= breakpoints.width.small) {
      this.maxItems = maxItemBreakpoints.medium;
      return;
    }
    if (width >= breakpoints.width.xsmall) {
      this.maxItems = maxItemBreakpoints.small;
      return;
    }
    this.maxItems = maxItemBreakpoints.xsmall;
  }
  getLastStart() {
    const { totalItems, pageSize, totalPages } = this;
    const lastStart = totalItems % pageSize === 0 ? totalItems - pageSize : Math.floor(totalPages) * pageSize;
    return lastStart + 1;
  }
  showStartEllipsis() {
    return (this.totalPages > this.maxItems &&
      Math.floor(this.startItem / this.pageSize) >
        this.maxItems - firstAndLastPageCount - ellipsisCount);
  }
  showEndEllipsis() {
    return (this.totalPages > this.maxItems &&
      (this.totalItems - this.startItem) / this.pageSize >
        this.maxItems - firstAndLastPageCount - (ellipsisCount - 1));
  }
  emitUpdate() {
    this.calcitePaginationChange.emit();
  }
  //--------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  renderEllipsis(type) {
    return (index.h("span", { class: {
        [CSS.ellipsis]: true,
        [CSS.ellipsisStart]: type === "start",
        [CSS.ellipsisEnd]: type === "end",
      }, key: type }, "\u2026"));
  }
  renderItems() {
    const { totalItems, pageSize, startItem, maxItems, totalPages } = this;
    const items = [];
    const renderFirstPage = totalItems > pageSize;
    const renderStartEllipsis = this.showStartEllipsis();
    const renderEndEllipsis = this.showEndEllipsis();
    const lastStart = this.getLastStart();
    if (renderFirstPage) {
      items.push(this.renderPage(1));
    }
    if (renderStartEllipsis) {
      items.push(this.renderEllipsis("start"));
    }
    const remainingItems = maxItems -
      firstAndLastPageCount -
      (renderEndEllipsis ? 1 : 0) -
      (renderStartEllipsis ? 1 : 0);
    let end;
    let nextStart;
    // if we don't need ellipses render the whole set
    if (totalPages - 1 <= remainingItems) {
      nextStart = 1 + pageSize;
      end = lastStart - pageSize;
    }
    else {
      // if we're within max pages of page 1
      if (startItem / pageSize < remainingItems) {
        nextStart = 1 + pageSize;
        end = 1 + remainingItems * pageSize;
      }
      else {
        // if we're within max pages of last page
        if (startItem + remainingItems * pageSize >= totalItems) {
          nextStart = lastStart - remainingItems * pageSize;
          end = lastStart - pageSize;
        }
        else {
          // if we're within the center pages
          nextStart = startItem - pageSize * ((remainingItems - 1) / 2);
          end = startItem + pageSize * ((remainingItems - 1) / 2);
        }
      }
    }
    for (let i = 0; i < remainingItems && nextStart <= end; i++) {
      items.push(this.renderPage(nextStart));
      nextStart = nextStart + pageSize;
    }
    if (renderEndEllipsis) {
      items.push(this.renderEllipsis("end"));
    }
    items.push(this.renderPage(lastStart));
    return items;
  }
  renderPage(start) {
    const { pageSize } = this;
    const page = Math.floor(start / pageSize) + (pageSize === 1 ? 0 : 1);
    locale.numberStringFormatter.numberFormatOptions = {
      locale: this.effectiveLocale,
      numberingSystem: this.numberingSystem,
      useGrouping: this.groupSeparator,
    };
    const displayedPage = locale.numberStringFormatter.localize(page.toString());
    const selected = start === this.startItem;
    return (index.h("button", { "aria-current": selected ? "page" : "false", class: {
        [CSS.page]: true,
        [CSS.selected]: selected,
      }, onClick: this.handlePageClick, value: start }, displayedPage));
  }
  render() {
    const { totalItems, pageSize, startItem, messages, scale } = this;
    const prevDisabled = pageSize === 1 ? startItem <= pageSize : startItem < pageSize;
    const nextDisabled = pageSize === 1 ? startItem + pageSize > totalItems : startItem + pageSize > totalItems;
    const iconScale = scale === "l" ? "m" : "s";
    return (index.h(index.Fragment, null, index.h("button", { "aria-label": messages.previous, class: {
        [CSS.previous]: true,
        [CSS.disabled]: prevDisabled,
      }, disabled: prevDisabled, onClick: this.previousClicked }, index.h("calcite-icon", { flipRtl: true, icon: ICONS.previous, scale: iconScale })), this.renderItems(), index.h("button", { "aria-label": messages.next, class: {
        [CSS.next]: true,
        [CSS.disabled]: nextDisabled,
      }, disabled: nextDisabled, onClick: this.nextClicked }, index.h("calcite-icon", { flipRtl: true, icon: ICONS.next, scale: iconScale }))));
  }
  static get delegatesFocus() { return true; }
  static get assetsDirs() { return ["assets"]; }
  get el() { return index.getElement(this); }
  static get watchers() { return {
    "messageOverrides": ["onMessagesChange"],
    "pageSize": ["handleTotalPages"],
    "totalItems": ["handleTotalPages"],
    "effectiveLocale": ["effectiveLocaleChange", "effectiveLocaleWatcher"]
  }; }
};
Pagination.style = paginationCss;

exports.calcite_pagination = Pagination;
