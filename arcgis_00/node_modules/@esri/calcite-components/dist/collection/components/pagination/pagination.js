/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.9.2
 */
import { Fragment, h, } from "@stencil/core";
import { componentFocusable, setComponentLoaded, setUpLoadableComponent, } from "../../utils/loadable";
import { connectLocalized, disconnectLocalized, numberStringFormatter, } from "../../utils/locale";
import { connectMessages, disconnectMessages, setUpMessages, updateMessages, } from "../../utils/t9n";
import { CSS, ICONS } from "./resources";
import { createObserver } from "../../utils/observers";
import { getBreakpoints } from "../../utils/responsive";
const firstAndLastPageCount = 2;
const ellipsisCount = 2;
const maxItemBreakpoints = {
  large: 11,
  medium: 9,
  small: 7,
  xsmall: 5,
};
export class Pagination {
  constructor() {
    this.resizeObserver = createObserver("resize", (entries) => entries.forEach(this.resizeHandler));
    this.resizeHandler = ({ contentRect: { width } }) => this.setMaxItemsToBreakpoint(width);
    this.previousClicked = async () => {
      await this.previousPage();
      this.emitUpdate();
    };
    this.nextClicked = async () => {
      await this.nextPage();
      this.emitUpdate();
    };
    this.handlePageClick = (event) => {
      const target = event.target;
      this.startItem = parseInt(target.value, 10);
      this.emitUpdate();
    };
    this.groupSeparator = false;
    this.messages = undefined;
    this.messageOverrides = undefined;
    this.numberingSystem = undefined;
    this.pageSize = 20;
    this.scale = "m";
    this.startItem = 1;
    this.totalItems = 0;
    this.defaultMessages = undefined;
    this.effectiveLocale = "";
    this.maxItems = maxItemBreakpoints.xsmall;
    this.totalPages = undefined;
  }
  onMessagesChange() {
    /* wired up by t9n util */
  }
  handleTotalPages() {
    this.totalPages = this.totalItems / this.pageSize;
  }
  effectiveLocaleChange() {
    updateMessages(this, this.effectiveLocale);
  }
  effectiveLocaleWatcher() {
    numberStringFormatter.numberFormatOptions = {
      locale: this.effectiveLocale,
      numberingSystem: this.numberingSystem,
      useGrouping: this.groupSeparator,
    };
  }
  // --------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  // --------------------------------------------------------------------------
  connectedCallback() {
    connectLocalized(this);
    connectMessages(this);
    this.resizeObserver?.observe(this.el);
  }
  async componentWillLoad() {
    const [, breakpoints] = await Promise.all([setUpMessages(this), getBreakpoints()]);
    this.breakpoints = breakpoints;
    setUpLoadableComponent(this);
    this.handleTotalPages();
  }
  componentDidLoad() {
    setComponentLoaded(this);
    this.setMaxItemsToBreakpoint(this.el.clientWidth);
  }
  disconnectedCallback() {
    disconnectLocalized(this);
    disconnectMessages(this);
    this.resizeObserver?.disconnect();
  }
  // --------------------------------------------------------------------------
  //
  //  Public Methods
  //
  // --------------------------------------------------------------------------
  /** Sets focus on the component's first focusable element. */
  async setFocus() {
    await componentFocusable(this);
    this.el.focus();
  }
  /** Go to the next page of results. */
  async nextPage() {
    this.startItem = Math.min(this.getLastStart(), this.startItem + this.pageSize);
  }
  /** Go to the previous page of results. */
  async previousPage() {
    this.startItem = Math.max(1, this.startItem - this.pageSize);
  }
  // --------------------------------------------------------------------------
  //
  //  Private Methods
  //
  // --------------------------------------------------------------------------
  setMaxItemsToBreakpoint(width) {
    const { breakpoints } = this;
    if (!breakpoints || !width) {
      return;
    }
    if (width >= breakpoints.width.medium) {
      this.maxItems = maxItemBreakpoints.large;
      return;
    }
    if (width >= breakpoints.width.small) {
      this.maxItems = maxItemBreakpoints.medium;
      return;
    }
    if (width >= breakpoints.width.xsmall) {
      this.maxItems = maxItemBreakpoints.small;
      return;
    }
    this.maxItems = maxItemBreakpoints.xsmall;
  }
  getLastStart() {
    const { totalItems, pageSize, totalPages } = this;
    const lastStart = totalItems % pageSize === 0 ? totalItems - pageSize : Math.floor(totalPages) * pageSize;
    return lastStart + 1;
  }
  showStartEllipsis() {
    return (this.totalPages > this.maxItems &&
      Math.floor(this.startItem / this.pageSize) >
        this.maxItems - firstAndLastPageCount - ellipsisCount);
  }
  showEndEllipsis() {
    return (this.totalPages > this.maxItems &&
      (this.totalItems - this.startItem) / this.pageSize >
        this.maxItems - firstAndLastPageCount - (ellipsisCount - 1));
  }
  emitUpdate() {
    this.calcitePaginationChange.emit();
  }
  //--------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  renderEllipsis(type) {
    return (h("span", { class: {
        [CSS.ellipsis]: true,
        [CSS.ellipsisStart]: type === "start",
        [CSS.ellipsisEnd]: type === "end",
      }, key: type }, "\u2026"));
  }
  renderItems() {
    const { totalItems, pageSize, startItem, maxItems, totalPages } = this;
    const items = [];
    const renderFirstPage = totalItems > pageSize;
    const renderStartEllipsis = this.showStartEllipsis();
    const renderEndEllipsis = this.showEndEllipsis();
    const lastStart = this.getLastStart();
    if (renderFirstPage) {
      items.push(this.renderPage(1));
    }
    if (renderStartEllipsis) {
      items.push(this.renderEllipsis("start"));
    }
    const remainingItems = maxItems -
      firstAndLastPageCount -
      (renderEndEllipsis ? 1 : 0) -
      (renderStartEllipsis ? 1 : 0);
    let end;
    let nextStart;
    // if we don't need ellipses render the whole set
    if (totalPages - 1 <= remainingItems) {
      nextStart = 1 + pageSize;
      end = lastStart - pageSize;
    }
    else {
      // if we're within max pages of page 1
      if (startItem / pageSize < remainingItems) {
        nextStart = 1 + pageSize;
        end = 1 + remainingItems * pageSize;
      }
      else {
        // if we're within max pages of last page
        if (startItem + remainingItems * pageSize >= totalItems) {
          nextStart = lastStart - remainingItems * pageSize;
          end = lastStart - pageSize;
        }
        else {
          // if we're within the center pages
          nextStart = startItem - pageSize * ((remainingItems - 1) / 2);
          end = startItem + pageSize * ((remainingItems - 1) / 2);
        }
      }
    }
    for (let i = 0; i < remainingItems && nextStart <= end; i++) {
      items.push(this.renderPage(nextStart));
      nextStart = nextStart + pageSize;
    }
    if (renderEndEllipsis) {
      items.push(this.renderEllipsis("end"));
    }
    items.push(this.renderPage(lastStart));
    return items;
  }
  renderPage(start) {
    const { pageSize } = this;
    const page = Math.floor(start / pageSize) + (pageSize === 1 ? 0 : 1);
    numberStringFormatter.numberFormatOptions = {
      locale: this.effectiveLocale,
      numberingSystem: this.numberingSystem,
      useGrouping: this.groupSeparator,
    };
    const displayedPage = numberStringFormatter.localize(page.toString());
    const selected = start === this.startItem;
    return (h("button", { "aria-current": selected ? "page" : "false", class: {
        [CSS.page]: true,
        [CSS.selected]: selected,
      }, onClick: this.handlePageClick, value: start }, displayedPage));
  }
  render() {
    const { totalItems, pageSize, startItem, messages, scale } = this;
    const prevDisabled = pageSize === 1 ? startItem <= pageSize : startItem < pageSize;
    const nextDisabled = pageSize === 1 ? startItem + pageSize > totalItems : startItem + pageSize > totalItems;
    const iconScale = scale === "l" ? "m" : "s";
    return (h(Fragment, null, h("button", { "aria-label": messages.previous, class: {
        [CSS.previous]: true,
        [CSS.disabled]: prevDisabled,
      }, disabled: prevDisabled, onClick: this.previousClicked }, h("calcite-icon", { flipRtl: true, icon: ICONS.previous, scale: iconScale })), this.renderItems(), h("button", { "aria-label": messages.next, class: {
        [CSS.next]: true,
        [CSS.disabled]: nextDisabled,
      }, disabled: nextDisabled, onClick: this.nextClicked }, h("calcite-icon", { flipRtl: true, icon: ICONS.next, scale: iconScale }))));
  }
  static get is() { return "calcite-pagination"; }
  static get encapsulation() { return "shadow"; }
  static get delegatesFocus() { return true; }
  static get originalStyleUrls() {
    return {
      "$": ["pagination.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["pagination.css"]
    };
  }
  static get assetsDirs() { return ["assets"]; }
  static get properties() {
    return {
      "groupSeparator": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "When `true`, number values are displayed with a group separator corresponding to the language and country format."
        },
        "attribute": "group-separator",
        "reflect": true,
        "defaultValue": "false"
      },
      "messages": {
        "type": "unknown",
        "mutable": true,
        "complexType": {
          "original": "PaginationMessages",
          "resolved": "{ next: string; previous: string; }",
          "references": {
            "PaginationMessages": {
              "location": "import",
              "path": "./assets/pagination/t9n"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "internal",
              "text": undefined
            }],
          "text": "Made into a prop for testing purposes only"
        }
      },
      "messageOverrides": {
        "type": "unknown",
        "mutable": true,
        "complexType": {
          "original": "Partial<PaginationMessages>",
          "resolved": "{ next?: string; previous?: string; }",
          "references": {
            "Partial": {
              "location": "global"
            },
            "PaginationMessages": {
              "location": "import",
              "path": "./assets/pagination/t9n"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Use this property to override individual strings used by the component."
        }
      },
      "numberingSystem": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "NumberingSystem",
          "resolved": "\"arab\" | \"arabext\" | \"bali\" | \"beng\" | \"deva\" | \"fullwide\" | \"gujr\" | \"guru\" | \"hanidec\" | \"khmr\" | \"knda\" | \"laoo\" | \"latn\" | \"limb\" | \"mlym\" | \"mong\" | \"mymr\" | \"orya\" | \"tamldec\" | \"telu\" | \"thai\" | \"tibt\"",
          "references": {
            "NumberingSystem": {
              "location": "import",
              "path": "../../utils/locale"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Specifies the Unicode numeral system used by the component for localization."
        },
        "attribute": "numbering-system",
        "reflect": false
      },
      "pageSize": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Specifies the number of items per page."
        },
        "attribute": "page-size",
        "reflect": true,
        "defaultValue": "20"
      },
      "scale": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "Scale",
          "resolved": "\"l\" | \"m\" | \"s\"",
          "references": {
            "Scale": {
              "location": "import",
              "path": "../interfaces"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Specifies the size of the component."
        },
        "attribute": "scale",
        "reflect": true,
        "defaultValue": "\"m\""
      },
      "startItem": {
        "type": "number",
        "mutable": true,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Specifies the starting item number."
        },
        "attribute": "start-item",
        "reflect": true,
        "defaultValue": "1"
      },
      "totalItems": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Specifies the total number of items."
        },
        "attribute": "total-items",
        "reflect": true,
        "defaultValue": "0"
      }
    };
  }
  static get states() {
    return {
      "defaultMessages": {},
      "effectiveLocale": {},
      "maxItems": {},
      "totalPages": {}
    };
  }
  static get events() {
    return [{
        "method": "calcitePaginationChange",
        "name": "calcitePaginationChange",
        "bubbles": true,
        "cancelable": false,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Emits when the selected page changes."
        },
        "complexType": {
          "original": "void",
          "resolved": "void",
          "references": {}
        }
      }];
  }
  static get methods() {
    return {
      "setFocus": {
        "complexType": {
          "signature": "() => Promise<void>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Sets focus on the component's first focusable element.",
          "tags": []
        }
      },
      "nextPage": {
        "complexType": {
          "signature": "() => Promise<void>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Go to the next page of results.",
          "tags": []
        }
      },
      "previousPage": {
        "complexType": {
          "signature": "() => Promise<void>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Go to the previous page of results.",
          "tags": []
        }
      }
    };
  }
  static get elementRef() { return "el"; }
  static get watchers() {
    return [{
        "propName": "messageOverrides",
        "methodName": "onMessagesChange"
      }, {
        "propName": "pageSize",
        "methodName": "handleTotalPages"
      }, {
        "propName": "totalItems",
        "methodName": "handleTotalPages"
      }, {
        "propName": "effectiveLocale",
        "methodName": "effectiveLocaleChange"
      }, {
        "propName": "effectiveLocale",
        "methodName": "effectiveLocaleWatcher"
      }];
  }
}
