import {
  H
} from "./chunk-AYPSI5Z4.js";
import "./chunk-EZFM2V6A.js";
import {
  I,
  T
} from "./chunk-B5VZ5MGX.js";
import {
  d as d3
} from "./chunk-XDEDL4UO.js";
import {
  m
} from "./chunk-T7A2C26A.js";
import "./chunk-BL72VOYB.js";
import {
  ee
} from "./chunk-FQFAKMK4.js";
import "./chunk-XZUCRWKB.js";
import "./chunk-S7KTKDEU.js";
import {
  f,
  g
} from "./chunk-TNVCH3GU.js";
import "./chunk-K5MRFCR6.js";
import "./chunk-UNQFOAUX.js";
import {
  rt,
  st
} from "./chunk-GZLGPJT5.js";
import "./chunk-XBCX74QQ.js";
import "./chunk-NUGAWFAM.js";
import "./chunk-KBZKT5PQ.js";
import "./chunk-HMTNVC7I.js";
import "./chunk-4XEDGKMA.js";
import "./chunk-BSCE3YT4.js";
import "./chunk-EFBQYSGH.js";
import "./chunk-H3A3DUAF.js";
import "./chunk-OBYHRJUR.js";
import "./chunk-GSCSASPY.js";
import {
  r
} from "./chunk-HXLO7LC5.js";
import "./chunk-5YQM3GC2.js";
import "./chunk-SUKBNOSX.js";
import "./chunk-3YWKHS6T.js";
import "./chunk-TQ73QHGP.js";
import "./chunk-5EIAXFYU.js";
import "./chunk-OOPW2AJ4.js";
import "./chunk-Z6VAQ2ZJ.js";
import "./chunk-MHACI6VO.js";
import {
  d as d2
} from "./chunk-IJCLSAKS.js";
import "./chunk-HXG3EAGH.js";
import "./chunk-PSEOYXGU.js";
import "./chunk-PDYDTTO6.js";
import "./chunk-V65JFJHR.js";
import "./chunk-Y2UHC2VM.js";
import "./chunk-7APSGFF5.js";
import "./chunk-S5RFXGTW.js";
import "./chunk-VEIPKRDL.js";
import "./chunk-2T74GJVJ.js";
import "./chunk-6VWXQUWW.js";
import "./chunk-WNCSTS7O.js";
import "./chunk-JU2JBJRJ.js";
import "./chunk-CBBETCDS.js";
import "./chunk-D3IA7B5F.js";
import "./chunk-RKDN5PXO.js";
import "./chunk-UILB2BFY.js";
import "./chunk-U4PYQFWE.js";
import "./chunk-FNONMLXB.js";
import "./chunk-7KNADJUA.js";
import {
  S2 as S,
  p
} from "./chunk-NMXESCE4.js";
import "./chunk-O6HKLIZS.js";
import "./chunk-FQMVGWVJ.js";
import "./chunk-VXRBE6UP.js";
import "./chunk-2IPRPVVF.js";
import "./chunk-DNUHV7J4.js";
import "./chunk-RRCNLKGG.js";
import "./chunk-RJHZ4FSH.js";
import "./chunk-DUGCD7YI.js";
import "./chunk-3CMERT4A.js";
import "./chunk-ZQWMLUHC.js";
import "./chunk-G5A25MBN.js";
import "./chunk-7LFT2RDJ.js";
import "./chunk-QPWNDO2C.js";
import "./chunk-CA2PXGXL.js";
import "./chunk-RXTTOJU7.js";
import {
  d,
  s as s3
} from "./chunk-4HAMAX2C.js";
import "./chunk-3QT5L2OK.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-5QASCMFT.js";
import "./chunk-GHZEFXB4.js";
import "./chunk-5G3YEFQP.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/graphics/sources/WFSSourceWorker.js
var d4 = class {
  constructor() {
    this._queryEngine = null, this._customParameters = null, this._snapshotFeatures = async (e) => {
      const { objectIdField: t } = this._queryEngine, r2 = await H(this._getFeatureUrl ?? "", this._featureType.typeName, this._getFeatureOutputFormat, { customParameters: this._customParameters, dateFields: this._queryEngine.fieldsIndex.dateFields.map((e2) => e2.name), signal: e });
      await T(r2), s3(e);
      const a = I(r2, { geometryType: this._queryEngine.geometryType, hasZ: false, objectIdField: t });
      if (!S(this._queryEngine.spatialReference, p))
        for (const s4 of a)
          null != s4.geometry && (s4.geometry = rt(g(st(s4.geometry, this._queryEngine.geometryType, false, false), p, this._queryEngine.spatialReference)));
      let p2 = 1;
      for (const s4 of a) {
        const e2 = {};
        d3(this._fieldsIndex, e2, s4.attributes, true), s4.attributes = e2, null == s4.attributes[t] && (s4.objectId = s4.attributes[t] = p2++);
      }
      return a;
    };
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = null;
  }
  async load(e, t) {
    const { getFeatureUrl: r2, getFeatureOutputFormat: a, spatialReference: i, fields: n, geometryType: o, featureType: u, objectIdField: h, customParameters: y } = e;
    this._featureType = u, this._customParameters = y, this._getFeatureUrl = r2, this._getFeatureOutputFormat = a, this._fieldsIndex = new r(n), await this._checkProjection(i), s3(t), this._queryEngine = new ee({ fields: n, geometryType: o, hasM: false, hasZ: false, objectIdField: h, spatialReference: i, timeInfo: null, featureStore: new m({ geometryType: o, hasM: false, hasZ: false }) });
    const l = await this._snapshotFeatures(t.signal);
    return this._queryEngine.featureStore.addMany(l), { extent: (await this._queryEngine.fetchRecomputedExtents()).fullExtent };
  }
  async applyEdits() {
    throw new s2("wfs-source:editing-not-supported", "applyEdits() is not supported on WFSLayer");
  }
  async queryFeatures(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t.signal);
  }
  async queryFeatureCount(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t.signal);
  }
  async queryObjectIds(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e, t.signal);
  }
  async queryExtent(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t.signal);
  }
  async querySnapping(e, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e, t.signal);
  }
  async refresh(s4) {
    var _a;
    return this._customParameters = s4, (_a = this._snapshotTask) == null ? void 0 : _a.abort(), this._snapshotTask = d2(this._snapshotFeatures), this._snapshotTask.promise.then((e) => {
      this._queryEngine.featureStore.clear(), e && this._queryEngine.featureStore.addMany(e);
    }, (e) => {
      this._queryEngine.featureStore.clear(), d(e) || s.getLogger("esri.layers.WFSLayer").error(new s2("wfs-layer:getfeature-error", "An error occurred during the GetFeature request", { error: e }));
    }), await this._waitSnapshotComplete(), { extent: (await this._queryEngine.fetchRecomputedExtents()).fullExtent };
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _checkProjection(e) {
    try {
      await f(p, e);
    } catch {
      throw new s2("unsupported-projection", "Projection not supported", { spatialReference: e });
    }
  }
};
export {
  d4 as default
};
//# sourceMappingURL=WFSSourceWorker-P5BOL3XQ.js.map
