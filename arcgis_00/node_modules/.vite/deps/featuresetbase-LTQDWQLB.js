import {
  b
} from "./chunk-UNPAWBXG.js";
import {
  t as t4
} from "./chunk-WQCRZBTT.js";
import {
  t as t3
} from "./chunk-EHLLIOB2.js";
import {
  A as A2,
  D,
  E as E2,
  F,
  T as T2,
  a,
  a2,
  c as c2,
  e as e2,
  e2 as e3,
  f as f2,
  g,
  j as j2,
  k,
  q as q2,
  x,
  y as y2
} from "./chunk-27TVZCBR.js";
import "./chunk-CMNH7HCC.js";
import {
  N,
  u2 as u
} from "./chunk-JSHFHFI2.js";
import "./chunk-BOSCDEFK.js";
import {
  l
} from "./chunk-VE3BCUJB.js";
import "./chunk-SFGFR54E.js";
import "./chunk-SJE6PNIV.js";
import "./chunk-EM5KTVEY.js";
import "./chunk-EZKKNHFJ.js";
import "./chunk-KVDAIVC6.js";
import "./chunk-E7T34AFG.js";
import "./chunk-7NWPWHPA.js";
import "./chunk-B5TYSRH2.js";
import "./chunk-HI2IDU34.js";
import "./chunk-GLQ6HYRE.js";
import "./chunk-C4L2TGDU.js";
import "./chunk-325OL72R.js";
import "./chunk-EIIX6MK3.js";
import "./chunk-WTKN55TU.js";
import "./chunk-TDPKDZC3.js";
import "./chunk-M5UHI5WR.js";
import {
  f
} from "./chunk-M7JVCLZD.js";
import "./chunk-UECUJRXY.js";
import {
  A
} from "./chunk-JVMGGRMI.js";
import {
  B,
  E,
  I2 as I,
  L,
  O,
  Pe,
  Q,
  Te,
  V,
  ce,
  fe,
  me,
  o,
  oe,
  q,
  t as t2,
  v,
  z
} from "./chunk-P7NSC4TA.js";
import {
  c
} from "./chunk-YAWND7HF.js";
import "./chunk-T5PUTFCO.js";
import {
  e,
  t
} from "./chunk-FJYIB7HF.js";
import {
  Be
} from "./chunk-OCKZY4KB.js";
import "./chunk-7RVJFKSW.js";
import "./chunk-JPSSRLNG.js";
import "./chunk-ZVP2JCAJ.js";
import "./chunk-LRYQNKYC.js";
import "./chunk-PAM4FXDN.js";
import "./chunk-4LMKB4SJ.js";
import "./chunk-2DE2MMH2.js";
import "./chunk-ILU5UH7D.js";
import "./chunk-6ALTXU4U.js";
import "./chunk-BPPSEHTY.js";
import "./chunk-MA4VBNWR.js";
import "./chunk-DTFJFPF7.js";
import "./chunk-ODP6NX3Y.js";
import "./chunk-UIMMV4OY.js";
import "./chunk-QZ4HHFPF.js";
import "./chunk-V56SNWAF.js";
import "./chunk-LLMRDEQF.js";
import "./chunk-UWP7BCPY.js";
import "./chunk-QMJALO7W.js";
import "./chunk-VRNAR2BU.js";
import "./chunk-IAMROCVA.js";
import "./chunk-7L7U6YJ3.js";
import "./chunk-NOI4I5TT.js";
import "./chunk-TPAPJ5F3.js";
import "./chunk-ENPG4N5M.js";
import "./chunk-D733RJGU.js";
import "./chunk-GVRDPBQU.js";
import "./chunk-YYGN2GO6.js";
import "./chunk-QXLGW66I.js";
import "./chunk-YGH3EEG5.js";
import "./chunk-H7EOZY7L.js";
import "./chunk-LKYCF7AI.js";
import "./chunk-DDZ6WPWX.js";
import "./chunk-ZVOARKLE.js";
import "./chunk-BY57CSP7.js";
import "./chunk-52ZYWMNY.js";
import "./chunk-FHYNSVC4.js";
import "./chunk-4HDCOJ24.js";
import "./chunk-VY2MIGMV.js";
import "./chunk-5BKFA3IG.js";
import "./chunk-R5EWWIOD.js";
import "./chunk-52L3OT7H.js";
import "./chunk-NHDVBH5V.js";
import "./chunk-WLU7KKOI.js";
import "./chunk-BA7WNJMF.js";
import "./chunk-ZZQVVHF7.js";
import "./chunk-SCOBW7KR.js";
import "./chunk-AHAGGZUI.js";
import "./chunk-JHVDJNJ7.js";
import "./chunk-M52YOZDN.js";
import "./chunk-P5CFKMGO.js";
import "./chunk-2EHBSKAM.js";
import "./chunk-HVBIBP5P.js";
import "./chunk-VLY2K2HC.js";
import "./chunk-AVOTXTN2.js";
import "./chunk-4FGKBJP7.js";
import "./chunk-LALFHQE3.js";
import "./chunk-IVCYO56U.js";
import "./chunk-JGFWZDK3.js";
import "./chunk-IN5QJ5F4.js";
import {
  y
} from "./chunk-C4I3X4RM.js";
import "./chunk-GVMBTEIW.js";
import "./chunk-5IXGL4JZ.js";
import "./chunk-HKDZF6LN.js";
import "./chunk-XR4HIGQP.js";
import "./chunk-BNNFX45U.js";
import "./chunk-U4IWFNWD.js";
import "./chunk-6L4U2AW6.js";
import "./chunk-LCWGEIX7.js";
import "./chunk-RFIIU6XF.js";
import "./chunk-DGADM4KQ.js";
import "./chunk-4CZO65BK.js";
import "./chunk-7C7EF3FD.js";
import "./chunk-PQOGMOZ7.js";
import "./chunk-XMS7FYO7.js";
import "./chunk-HOGRNOD4.js";
import "./chunk-NZY6MEON.js";
import "./chunk-D76KSV7G.js";
import "./chunk-2H7DV6BT.js";
import "./chunk-Z74XNIJ3.js";
import "./chunk-GRS3EHGG.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-EIE3W25Z.js";
import "./chunk-TNYMHVJ4.js";
import "./chunk-OZXJDVTE.js";
import "./chunk-Z6HMRH7V.js";
import "./chunk-JZBA2N4X.js";
import "./chunk-4W4V5TBI.js";
import "./chunk-HABV4VZ2.js";
import "./chunk-2D2437VM.js";
import "./chunk-YIIAB4WA.js";
import "./chunk-KTSEQWMB.js";
import "./chunk-FUHI6TR6.js";
import "./chunk-FVYUULND.js";
import {
  j
} from "./chunk-BRRN7CRU.js";
import "./chunk-TLIPFBCN.js";
import "./chunk-7KTXAH5E.js";
import "./chunk-WYE6B4VU.js";
import "./chunk-5XLKQQPP.js";
import "./chunk-X5ASTC4J.js";
import "./chunk-3OL5L3LC.js";
import "./chunk-H7C32RFW.js";
import "./chunk-RNYFZDNI.js";
import "./chunk-FBG4WSP5.js";
import "./chunk-G3X4SV7G.js";
import "./chunk-AJM6LB5B.js";
import "./chunk-G4LADD2B.js";
import "./chunk-HLTEFNTE.js";
import "./chunk-CO3TM5QL.js";
import "./chunk-FARQZCLL.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-E5XSQEGK.js";
import "./chunk-MZXYP6SL.js";
import "./chunk-4X5MDDUC.js";
import "./chunk-UURR7HU3.js";
import "./chunk-JLE6P4DW.js";
import "./chunk-OHLUZSH7.js";
import "./chunk-QV5AXXWQ.js";
import "./chunk-CL7UAIKB.js";
import "./chunk-F3SBJW2O.js";
import "./chunk-YVCC2Z32.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-YC3PYTAZ.js";
import "./chunk-46JSCFRH.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-VPF2CM6B.js";
import "./chunk-JCWF5RB4.js";
import "./chunk-TBBTJ7N4.js";
import "./chunk-NUI5LCQ5.js";
import "./chunk-AS7ITRBV.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-SF7FIURP.js";
import "./chunk-K7YQIZQM.js";
import "./chunk-H3ETM4DZ.js";
import "./chunk-TXAS6RAG.js";
import {
  T
} from "./chunk-G72U56FP.js";
import "./chunk-DWOEYHKS.js";
import "./chunk-JGYHKABU.js";
import "./chunk-3FXB2ZFK.js";
import "./chunk-WQNVH5M4.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/arcade/functions/featuresetbase.js
function J(e4, t5, n, i) {
  if (1 === i.length) {
    if (z(i[0]))
      return l(e4, i[0], -1);
    if (q(i[0]))
      return l(e4, i[0].toArray(), -1);
  }
  return l(e4, i, -1);
}
async function K(e4, t5, n) {
  const i = e4.getVariables();
  if (i.length > 0) {
    const a3 = [];
    for (let e5 = 0; e5 < i.length; e5++) {
      const r2 = { name: i[e5] };
      a3.push(await t5.evaluateIdentifier(n, r2));
    }
    const r = {};
    for (let e5 = 0; e5 < i.length; e5++)
      r[i[e5]] = a3[e5];
    return e4.parameters = r, e4;
  }
  return e4;
}
function Y(e4, t5, n = null) {
  for (const i in e4)
    if (i.toLowerCase() === t5.toLowerCase())
      return e4[i];
  return n;
}
function X(e4) {
  if (null === e4)
    return null;
  const t5 = { type: Y(e4, "type", ""), name: Y(e4, "name", "") };
  if ("range" === t5.type)
    t5.range = Y(e4, "range", []);
  else {
    t5.codedValues = [];
    for (const n of Y(e4, "codedValues", []))
      t5.codedValues.push({ name: Y(n, "name", ""), code: Y(n, "code", null) });
  }
  return t5;
}
function ee(e4) {
  if (null === e4)
    return null;
  const t5 = {}, n = Y(e4, "wkt", null);
  null !== n && (t5.wkt = n);
  const i = Y(e4, "wkid", null);
  return null !== i && (t5.wkid = i), t5;
}
function te(e4) {
  if (null === e4)
    return null;
  const t5 = { hasZ: Y(e4, "hasz", false), hasM: Y(e4, "hasm", false) }, n = Y(e4, "spatialreference", null);
  n && (t5.spatialReference = ee(n));
  const i = Y(e4, "x", null);
  if (null !== i)
    return t5.x = i, t5.y = Y(e4, "y", null), t5;
  const a3 = Y(e4, "rings", null);
  if (null !== a3)
    return t5.rings = a3, t5;
  const r = Y(e4, "paths", null);
  if (null !== r)
    return t5.paths = r, t5;
  const s = Y(e4, "points", null);
  if (null !== s)
    return t5.points = s, t5;
  for (const l2 of ["xmin", "xmax", "ymin", "ymax", "zmin", "zmax", "mmin", "mmax"]) {
    const n2 = Y(e4, l2, null);
    null !== n2 && (t5[l2] = n2);
  }
  return t5;
}
function ne(e4, t5) {
  for (const n of t5)
    if (n === e4)
      return true;
  return false;
}
function ie(e4) {
  return !!e4.layerDefinition && (!!e4.featureSet && (false !== ne(e4.layerDefinition.geometryType, ["", null, "esriGeometryNull", "esriGeometryPoint", "esriGeometryPolyline", "esriGeometryPolygon", "esriGeometryMultipoint", "esriGeometryEnvelope"]) && (false !== z(e4.layerDefinition.fields) && false !== z(e4.featureSet.features))));
}
function ae(_) {
  "async" === _.mode && (_.functions.timezone = function(t5, r) {
    return _.standardFunctionAsync(t5, r, async (s, l2, o2) => {
      if (Q(o2, 1, 2, t5, r), V(o2[0])) {
        if (await o2[0].load(), 1 === o2.length || null === o2[1])
          return o2[0].dateTimeReferenceFieldIndex.layerDateFieldsTimeZone;
        if (!(o2[1] instanceof A) || false === o2[1].hasField("type"))
          throw new t(t5, e.InvalidParameter, r);
        const e4 = o2[1].field("type");
        if (false === L(e4))
          throw new t(t5, e.InvalidParameter, r);
        switch (oe(e4).toLowerCase()) {
          case "preferredtimezone":
            return o2[0].dateTimeReferenceFieldIndex.layerPreferredTimeZone;
          case "editfieldsinfo":
            return o2[0].dateTimeReferenceFieldIndex.layerEditFieldsTimeZone;
          case "timeinfo":
            return o2[0].dateTimeReferenceFieldIndex.layerTimeInfoTimeZone;
          case "field":
            if (o2[1].hasField("fieldname") && L(o2[1].field("fieldname")))
              return o2[0].dateTimeReferenceFieldIndex.fieldTimeZone(oe(o2[1].field("fieldname")));
        }
        throw new t(t5, e.InvalidParameter, r);
      }
      const f3 = ce(o2[0], Pe(t5));
      if (null === f3)
        return null;
      const u2 = f3.timeZone;
      return "system" === u2 ? c.systemTimeZoneCanonicalName : u2;
    });
  }, _.functions.sqltimestamp = function(e4, t5) {
    return _.standardFunctionAsync(e4, t5, async (n, r, s) => {
      Q(s, 1, 3, e4, t5);
      const l2 = s[0];
      if (B(l2)) {
        if (1 === s.length)
          return l2.toSQLString();
        if (2 === s.length)
          return l2.changeTimeZone(oe(s[1])).toSQLString();
        throw new t(e4, e.InvalidParameter, t5);
      }
      if (V(l2)) {
        if (3 !== s.length)
          throw new t(e4, e.InvalidParameter, t5);
        await l2.load();
        const n2 = oe(s[1]);
        if (false === B(s[2]))
          throw new t(e4, e.InvalidParameter, t5);
        const r2 = l2.fieldTimeZone(n2);
        return null === r2 ? s[2].toSQLString() : s[2].changeTimeZone(r2).toSQLString();
      }
      throw new t(e4, e.InvalidParameter, t5);
    });
  }, _.signatures.push({ name: "sqltimestamp", min: 2, max: 4 }), _.functions.featuresetbyid = function(e4, t5) {
    return _.standardFunctionAsync(e4, t5, (n, r, l2) => {
      if (Q(l2, 2, 4, e4, t5), l2[0] instanceof e2) {
        const n2 = oe(l2[1]);
        let r2 = v(l2[2], null);
        const s = me(v(l2[3], true));
        if (null === r2 && (r2 = ["*"]), false === z(r2))
          throw new t(e4, e.InvalidParameter, t5);
        return l2[0].featureSetById(n2, s, r2);
      }
      throw new t(e4, e.InvalidParameter, t5);
    });
  }, _.signatures.push({ name: "featuresetbyid", min: 2, max: 4 }), _.functions.getfeatureset = function(e4, t5) {
    return _.standardFunctionAsync(e4, t5, (n, r, s) => {
      if (Q(s, 1, 2, e4, t5), E(s[0])) {
        let t6 = v(s[1], "datasource");
        return null === t6 && (t6 = "datasource"), t6 = oe(t6).toLowerCase(), j2(s[0].fullSchema(), t6, e4.lrucache, e4.interceptor, e4.spatialReference);
      }
      throw new t(e4, e.InvalidParameter, t5);
    });
  }, _.signatures.push({ name: "getfeatureset", min: 1, max: 2 }), _.functions.featuresetbyportalitem = function(e4, n) {
    return _.standardFunctionAsync(e4, n, (r, s, l2) => {
      var _a;
      if (Q(l2, 2, 5, e4, n), null === l2[0])
        throw new t(e4, e.PortalRequired, n);
      if (l2[0] instanceof t3) {
        const t5 = oe(l2[1]), r2 = oe(l2[2]);
        let s2 = v(l2[3], null);
        const f4 = me(v(l2[4], true));
        if (null === s2 && (s2 = ["*"]), false === z(s2))
          throw new t(e4, e.InvalidParameter, n);
        let u3 = null;
        return u3 = e4.services && e4.services.portal ? e4.services.portal : j.getDefault(), u3 = t4(l2[0], u3), q2(t5, r2, e4.spatialReference, s2, f4, u3, e4.lrucache, e4.interceptor);
      }
      if (false === L(l2[0]))
        throw new t(e4, e.PortalRequired, n);
      const f3 = oe(l2[0]), u2 = oe(l2[1]);
      let c3 = v(l2[2], null);
      const d = me(v(l2[3], true));
      if (null === c3 && (c3 = ["*"]), false === z(c3))
        throw new t(e4, e.InvalidParameter, n);
      return q2(f3, u2, e4.spatialReference, c3, d, ((_a = e4.services) == null ? void 0 : _a.portal) ?? j.getDefault(), e4.lrucache, e4.interceptor);
    });
  }, _.signatures.push({ name: "featuresetbyportalitem", min: 2, max: 5 }), _.functions.featuresetbyname = function(e4, t5) {
    return _.standardFunctionAsync(e4, t5, (n, r, l2) => {
      if (Q(l2, 2, 4, e4, t5), l2[0] instanceof e2) {
        const n2 = oe(l2[1]);
        let r2 = v(l2[2], null);
        const s = me(v(l2[3], true));
        if (null === r2 && (r2 = ["*"]), false === z(r2))
          throw new t(e4, e.InvalidParameter, t5);
        return l2[0].featureSetByName(n2, s, r2);
      }
      throw new t(e4, e.InvalidParameter, t5);
    });
  }, _.signatures.push({ name: "featuresetbyname", min: 2, max: 4 }), _.functions.featureset = function(e4, t5) {
    return _.standardFunction(e4, t5, (r, s, l2) => {
      var _a;
      Q(l2, 1, 1, e4, t5);
      let o2 = l2[0];
      const f3 = { layerDefinition: { geometryType: "", objectIdField: "", hasM: false, hasZ: false, globalIdField: "", typeIdField: "", fields: [] }, featureSet: { geometryType: "", features: [] } };
      if (L(o2))
        o2 = JSON.parse(o2), void 0 !== o2.layerDefinition ? (f3.layerDefinition = o2.layerDefinition, f3.featureSet = o2.featureSet, o2.layerDefinition.spatialReference && (f3.layerDefinition.spatialReference = o2.layerDefinition.spatialReference)) : (f3.featureSet.features = o2.features, f3.featureSet.geometryType = o2.geometryType, f3.layerDefinition.geometryType = f3.featureSet.geometryType, f3.layerDefinition.objectIdField = o2.objectIdFieldName ?? "", f3.layerDefinition.typeIdField = o2.typeIdFieldName, f3.layerDefinition.globalIdField = o2.globalIdFieldName, f3.layerDefinition.fields = o2.fields, o2.spatialReference && (f3.layerDefinition.spatialReference = o2.spatialReference));
      else {
        if (!(l2[0] instanceof A))
          throw new t(e4, e.InvalidParameter, t5);
        {
          o2 = JSON.parse(l2[0].castToText(true));
          const e5 = Y(o2, "layerdefinition");
          if (null !== e5) {
            f3.layerDefinition.geometryType = Y(e5, "geometrytype", ""), f3.featureSet.geometryType = f3.layerDefinition.geometryType, f3.layerDefinition.globalIdField = Y(e5, "globalidfield", ""), f3.layerDefinition.objectIdField = Y(e5, "objectidfield", ""), f3.layerDefinition.typeIdField = Y(e5, "typeidfield", ""), f3.layerDefinition.hasZ = true === Y(e5, "hasz", false), f3.layerDefinition.hasM = true === Y(e5, "hasm", false);
            const t6 = Y(e5, "spatialreference", null);
            t6 && (f3.layerDefinition.spatialReference = ee(t6));
            for (const i of Y(e5, "fields", [])) {
              const e6 = { name: Y(i, "name", ""), alias: Y(i, "alias", ""), type: Y(i, "type", ""), nullable: Y(i, "nullable", true), editable: Y(i, "editable", true), length: Y(i, "length", null), domain: X(Y(i, "domain")) };
              f3.layerDefinition.fields.push(e6);
            }
            const n = Y(o2, "featureset", null);
            if (n) {
              const e6 = {};
              for (const t7 of f3.layerDefinition.fields)
                e6[t7.name.toLowerCase()] = t7.name;
              for (const t7 of Y(n, "features", [])) {
                const n2 = {}, i = Y(t7, "attributes", {});
                for (const t8 in i)
                  n2[e6[t8.toLowerCase()]] = i[t8];
                f3.featureSet.features.push({ attributes: n2, geometry: te(Y(t7, "geometry", null)) });
              }
            }
          } else {
            f3.layerDefinition.hasZ = true === Y(o2, "hasz", false), f3.layerDefinition.hasM = true === Y(o2, "hasm", false), f3.layerDefinition.geometryType = Y(o2, "geometrytype", ""), f3.featureSet.geometryType = f3.layerDefinition.geometryType, f3.layerDefinition.objectIdField = Y(o2, "objectidfieldname", ""), f3.layerDefinition.typeIdField = Y(o2, "typeidfieldname", "");
            const e6 = Y(o2, "spatialreference", null);
            e6 && (f3.layerDefinition.spatialReference = ee(e6));
            let t6 = Y(o2, "fields", null);
            if (z(t6))
              for (const a3 of t6) {
                const e7 = { name: Y(a3, "name", ""), alias: Y(a3, "alias", ""), type: Y(a3, "type", ""), nullable: Y(a3, "nullable", true), editable: Y(a3, "editable", true), length: Y(a3, "length", null), domain: X(Y(a3, "domain")) };
                f3.layerDefinition.fields.push(e7);
              }
            else
              t6 = null, f3.layerDefinition.fields = t6;
            const n = {};
            for (const a3 of f3.layerDefinition.fields)
              n[a3.name.toLowerCase()] = a3.name;
            let i = Y(o2, "features", null);
            if (z(i))
              for (const a3 of i) {
                const e7 = {}, t7 = Y(a3, "attributes", {});
                for (const i2 in t7)
                  e7[n[i2.toLowerCase()]] = t7[i2];
                f3.featureSet.features.push({ attributes: e7, geometry: te(Y(a3, "geometry", null)) });
              }
            else
              i = null, f3.featureSet.features = i;
          }
        }
      }
      if (false === ie(f3))
        throw new t(e4, e.InvalidParameter, t5);
      return "" === (((_a = f3 == null ? void 0 : f3.layerDefinition) == null ? void 0 : _a.geometryType) || "") && (f3.layerDefinition.geometryType = "esriGeometryNull"), f2.create(f3, e4.spatialReference);
    });
  }, _.signatures.push({ name: "featureset", min: 1, max: 1 }), _.functions.filter = function(e4, t5) {
    return _.standardFunctionAsync(e4, t5, async (n, r, s) => {
      if (Q(s, 2, 2, e4, t5), z(s[0]) || q(s[0])) {
        const n2 = [];
        let r2 = s[0];
        r2 instanceof t2 && (r2 = r2.toArray());
        let l2 = null;
        if (!O(s[1]))
          throw new t(e4, e.InvalidParameter, t5);
        l2 = s[1].createFunction(e4);
        for (const e5 of r2) {
          const t6 = l2(e5);
          T(t6) ? true === await t6 && n2.push(e5) : true === t6 && n2.push(e5);
        }
        return n2;
      }
      if (V(s[0])) {
        const t6 = await s[0].load(), n2 = f.create(s[1], t6.getFieldsIndex()), i = n2.getVariables();
        if (i.length > 0) {
          const t7 = [];
          for (let n3 = 0; n3 < i.length; n3++) {
            const a4 = { name: i[n3] };
            t7.push(await _.evaluateIdentifier(e4, a4));
          }
          const a3 = {};
          for (let e5 = 0; e5 < i.length; e5++)
            a3[i[e5]] = t7[e5];
          return n2.parameters = a3, new c2({ parentfeatureset: s[0], whereclause: n2 });
        }
        return new c2({ parentfeatureset: s[0], whereclause: n2 });
      }
      throw new t(e4, e.InvalidParameter, t5);
    });
  }, _.signatures.push({ name: "filter", min: 2, max: 2 }), _.functions.orderby = function(e4, t5) {
    return _.standardFunctionAsync(e4, t5, async (n, r, s) => {
      if (Q(s, 2, 2, e4, t5), V(s[0])) {
        const e5 = new e3(s[1]);
        return new a({ parentfeatureset: s[0], orderbyclause: e5 });
      }
      throw new t(e4, e.InvalidParameter, t5);
    });
  }, _.signatures.push({ name: "orderby", min: 2, max: 2 }), _.functions.top = function(e4, t5) {
    return _.standardFunctionAsync(e4, t5, async (n, r, s) => {
      if (Q(s, 2, 2, e4, t5), V(s[0]))
        return new a2({ parentfeatureset: s[0], topnum: s[1] });
      if (z(s[0]))
        return fe(s[1]) >= s[0].length ? s[0].slice(0) : s[0].slice(0, fe(s[1]));
      if (q(s[0]))
        return fe(s[1]) >= s[0].length() ? s[0].slice(0) : s[0].slice(0, fe(s[1]));
      throw new t(e4, e.InvalidParameter, t5);
    });
  }, _.signatures.push({ name: "top", min: 2, max: 2 }), _.functions.first = function(e4, t5) {
    return _.standardFunctionAsync(e4, t5, async (n, i, a3) => {
      if (Q(a3, 1, 1, e4, t5), V(a3[0])) {
        const t6 = await a3[0].first(n.abortSignal);
        if (null !== t6) {
          const n2 = b.createFromGraphicLikeObject(t6.geometry, t6.attributes, a3[0], e4.timeReference);
          return n2._underlyingGraphic = t6, n2;
        }
        return t6;
      }
      return z(a3[0]) ? 0 === a3[0].length ? null : a3[0][0] : q(a3[0]) ? 0 === a3[0].length() ? null : a3[0].get(0) : null;
    });
  }, _.signatures.push({ name: "first", min: 1, max: 1 }), _.functions.attachments = function(e4, t5) {
    return _.standardFunctionAsync(e4, t5, async (r, s, l2) => {
      Q(l2, 1, 2, e4, t5);
      const o2 = { minsize: -1, maxsize: -1, types: null, returnMetadata: false };
      if (l2.length > 1) {
        if (l2[1] instanceof A) {
          if (l2[1].hasField("minsize") && (o2.minsize = fe(l2[1].field("minsize"))), l2[1].hasField("metadata") && (o2.returnMetadata = me(l2[1].field("metadata"))), l2[1].hasField("maxsize") && (o2.maxsize = fe(l2[1].field("maxsize"))), l2[1].hasField("types")) {
            const e5 = Te(l2[1].field("types"), false);
            e5.length > 0 && (o2.types = e5);
          }
        } else if (null !== l2[1])
          throw new t(e4, e.InvalidParameter, t5);
      }
      if (E(l2[0])) {
        let t6 = l2[0]._layer;
        return t6 instanceof Be && (t6 = g(t6, e4.spatialReference, ["*"], true, e4.lrucache, e4.interceptor)), null === t6 ? [] : false === V(t6) ? [] : (await t6.load(), t6.queryAttachments(l2[0].field(t6.objectIdField), o2.minsize, o2.maxsize, o2.types, o2.returnMetadata));
      }
      if (null === l2[0])
        return [];
      throw new t(e4, e.InvalidParameter, t5);
    });
  }, _.signatures.push({ name: "attachments", min: 1, max: 2 }), _.functions.featuresetbyrelationshipname = function(e4, t5) {
    return _.standardFunctionAsync(e4, t5, async (n, r, s) => {
      Q(s, 2, 4, e4, t5);
      const l2 = s[0], o2 = oe(s[1]);
      let d = v(s[2], null);
      const m = me(v(s[3], true));
      if (null === d && (d = ["*"]), false === z(d))
        throw new t(e4, e.InvalidParameter, t5);
      if (null === s[0])
        return null;
      if (!E(s[0]))
        throw new t(e4, e.InvalidParameter, t5);
      let h = l2._layer;
      if (h instanceof Be && (h = g(h, e4.spatialReference, ["*"], true, e4.lrucache, e4.interceptor)), null === h)
        return null;
      if (false === V(h))
        return null;
      h = await h.load();
      const w = h.relationshipMetaData().filter((e5) => e5.name === o2);
      if (0 === w.length)
        return null;
      if (void 0 !== w[0].relationshipTableId && null !== w[0].relationshipTableId && w[0].relationshipTableId > -1)
        return k(h, w[0], l2.field(h.objectIdField), h.spatialReference, d, m, e4.lrucache, e4.interceptor);
      let I2 = h.serviceUrl();
      if (!I2)
        return null;
      I2 = "/" === I2.charAt(I2.length - 1) ? I2 + w[0].relatedTableId.toString() : I2 + "/" + w[0].relatedTableId.toString();
      const F2 = await F(I2, h.spatialReference, d, m, e4.lrucache, e4.interceptor);
      await F2.load();
      let A3 = F2.relationshipMetaData();
      if (A3 = A3.filter((e5) => e5.id === w[0].id), false === l2.hasField(w[0].keyField) || null === l2.field(w[0].keyField)) {
        const e5 = await h.getFeatureByObjectId(l2.field(h.objectIdField), [w[0].keyField]);
        if (e5) {
          const t6 = f.create(A3[0].keyField + "= @id", F2.getFieldsIndex());
          return t6.parameters = { id: e5.attributes[w[0].keyField] }, F2.filter(t6);
        }
        return new u({ parentfeatureset: F2 });
      }
      const N2 = f.create(A3[0].keyField + "= @id", F2.getFieldsIndex());
      return N2.parameters = { id: l2.field(w[0].keyField) }, F2.filter(N2);
    });
  }, _.signatures.push({ name: "featuresetbyrelationshipname", min: 2, max: 4 }), _.functions.featuresetbyassociation = function(e4, t5) {
    return _.standardFunctionAsync(e4, t5, async (n, r, s) => {
      Q(s, 2, 3, e4, t5);
      const l2 = s[0], o2 = oe(v(s[1], "")).toLowerCase(), u2 = L(s[2]) ? oe(s[2]) : null;
      if (null === s[0])
        return null;
      if (!E(s[0]))
        throw new t(e4, e.InvalidParameter, t5);
      let c3 = l2._layer;
      if (c3 instanceof Be && (c3 = g(c3, e4.spatialReference, ["*"], true, e4.lrucache, e4.interceptor)), null === c3)
        return null;
      if (false === V(c3))
        return null;
      await c3.load();
      const m = c3.serviceUrl(), w = await T2(m, e4.spatialReference);
      let I2 = null, F2 = null, E3 = false;
      if (null !== u2 && "" !== u2 && void 0 !== u2) {
        for (const e5 of w.terminals)
          e5.terminalName === u2 && (F2 = e5.terminalId);
        null === F2 && (E3 = true);
      }
      const b2 = w.associations.getFieldsIndex(), A3 = b2.get("TOGLOBALID").name, N2 = b2.get("FROMGLOBALID").name, S = b2.get("TOTERMINALID").name, T3 = b2.get("FROMTERMINALID").name, $ = b2.get("FROMNETWORKSOURCEID").name, M = b2.get("TONETWORKSOURCEID").name, O2 = b2.get("ASSOCIATIONTYPE").name, k2 = b2.get("ISCONTENTVISIBLE").name, z2 = b2.get("OBJECTID").name;
      for (const e5 of c3.fields)
        if ("global-id" === e5.type) {
          I2 = l2.field(e5.name);
          break;
        }
      let H = null, Z = new y2(new y({ name: "percentalong", alias: "percentalong", type: "double" }), f.create("0", w.associations.getFieldsIndex())), W = new y2(new y({ name: "side", alias: "side", type: "string" }), f.create("''", w.associations.getFieldsIndex()));
      const _2 = "globalid", U = "globalId", Q2 = {};
      for (const e5 in w.lkp)
        Q2[e5] = w.lkp[e5].sourceId;
      const J2 = new x(new y({ name: "classname", alias: "classname", type: "string" }), null, Q2);
      let K2 = "";
      switch (o2) {
        case "midspan": {
          K2 = `((${A3}='${I2}') OR ( ${N2}='${I2}')) AND (${O2} IN (5))`, J2.codefield = f.create(`CASE WHEN (${A3}='${I2}') THEN ${$} ELSE ${M} END`, w.associations.getFieldsIndex());
          const e5 = o(D.findField(w.associations.fields, N2));
          e5.name = _2, e5.alias = _2, H = new y2(e5, f.create(`CASE WHEN (${N2}='${I2}') THEN ${A3} ELSE ${N2} END`, w.associations.getFieldsIndex())), Z = w.unVersion >= 4 ? new A2(D.findField(w.associations.fields, b2.get("PERCENTALONG").name)) : new y2(new y({ name: "percentalong", alias: "percentalong", type: "double" }), f.create("0", w.associations.getFieldsIndex()));
          break;
        }
        case "junctionedge": {
          K2 = `((${A3}='${I2}') OR ( ${N2}='${I2}')) AND (${O2} IN (4,6))`, J2.codefield = f.create(`CASE WHEN (${A3}='${I2}') THEN ${$} ELSE ${M} END`, w.associations.getFieldsIndex());
          const e5 = o(D.findField(w.associations.fields, N2));
          e5.name = _2, e5.alias = _2, H = new y2(e5, f.create(`CASE WHEN (${N2}='${I2}') THEN ${A3} ELSE ${N2} END`, w.associations.getFieldsIndex())), W = new y2(new y({ name: "side", alias: "side", type: "string" }), f.create(`CASE WHEN (${O2}=4) THEN 'from' ELSE 'to' END`, w.associations.getFieldsIndex()));
          break;
        }
        case "connected": {
          let e5 = `${A3}='@T'`, t6 = `${N2}='@T'`;
          null !== F2 && (e5 += ` AND ${S}=@A`, t6 += ` AND ${T3}=@A`), K2 = "((" + e5 + ") OR (" + t6 + "))", K2 = I(K2, "@T", I2 ?? ""), e5 = I(e5, "@T", I2 ?? ""), null !== F2 && (e5 = I(e5, "@A", F2.toString()), K2 = I(K2, "@A", F2.toString())), J2.codefield = f.create("CASE WHEN " + e5 + ` THEN ${$} ELSE ${M} END`, w.associations.getFieldsIndex());
          const n2 = o(D.findField(w.associations.fields, N2));
          n2.name = _2, n2.alias = _2, H = new y2(n2, f.create("CASE WHEN " + e5 + ` THEN ${N2} ELSE ${A3} END`, w.associations.getFieldsIndex()));
          break;
        }
        case "container":
          K2 = `${A3}='${I2}' AND ${O2} = 2`, null !== F2 && (K2 += ` AND ${S} = ` + F2.toString()), J2.codefield = $, K2 = "( " + K2 + " )", H = new E2(D.findField(w.associations.fields, N2), _2, _2);
          break;
        case "content":
          K2 = `(${N2}='${I2}' AND ${O2} = 2)`, null !== F2 && (K2 += ` AND ${T3} = ` + F2.toString()), J2.codefield = M, K2 = "( " + K2 + " )", H = new E2(D.findField(w.associations.fields, A3), _2, _2);
          break;
        case "structure":
          K2 = `(${A3}='${I2}' AND ${O2} = 3)`, null !== F2 && (K2 += ` AND ${S} = ` + F2.toString()), J2.codefield = $, K2 = "( " + K2 + " )", H = new E2(D.findField(w.associations.fields, N2), _2, U);
          break;
        case "attached":
          K2 = `(${N2}='${I2}' AND ${O2} = 3)`, null !== F2 && (K2 += ` AND ${T3} = ` + F2.toString()), J2.codefield = M, K2 = "( " + K2 + " )", H = new E2(D.findField(w.associations.fields, A3), _2, U);
          break;
        default:
          throw new t(e4, e.InvalidParameter, t5);
      }
      E3 && (K2 = "1 <> 1");
      return new D({ parentfeatureset: w.associations, adaptedFields: [new A2(D.findField(w.associations.fields, z2)), new A2(D.findField(w.associations.fields, k2)), H, W, J2, Z], extraFilter: K2 ? f.create(K2, w.associations.getFieldsIndex()) : null });
    });
  }, _.signatures.push({ name: "featuresetbyassociation", min: 2, max: 6 }), _.functions.groupby = function(e4, t5) {
    return _.standardFunctionAsync(e4, t5, async (r, s, l2) => {
      if (Q(l2, 3, 3, e4, t5), !V(l2[0]))
        throw new t(e4, e.InvalidParameter, t5);
      const o2 = await l2[0].load(), f3 = [], u2 = [];
      let c3 = false, d = [];
      if (L(l2[1]))
        d.push(l2[1]);
      else if (l2[1] instanceof A)
        d.push(l2[1]);
      else if (z(l2[1]))
        d = l2[1];
      else {
        if (!q(l2[1]))
          throw new t(e4, e.InvalidParameter, t5);
        d = l2[1].toArray();
      }
      for (const m of d)
        if (L(m)) {
          const e5 = f.create(oe(m), o2.getFieldsIndex()), t6 = true === N(e5) ? oe(m) : "%%%%FIELDNAME";
          f3.push({ name: t6, expression: e5 }), "%%%%FIELDNAME" === t6 && (c3 = true);
        } else {
          if (!(m instanceof A))
            throw new t(e4, e.InvalidParameter, t5);
          {
            const n = m.hasField("name") ? m.field("name") : "%%%%FIELDNAME", r2 = m.hasField("expression") ? m.field("expression") : "";
            if ("%%%%FIELDNAME" === n && (c3 = true), !n)
              throw new t(e4, e.InvalidParameter, t5);
            f3.push({ name: n, expression: f.create(r2 || n, o2.getFieldsIndex()) });
          }
        }
      if (d = [], L(l2[2]))
        d.push(l2[2]);
      else if (z(l2[2]))
        d = l2[2];
      else if (q(l2[2]))
        d = l2[2].toArray();
      else {
        if (!(l2[2] instanceof A))
          throw new t(e4, e.InvalidParameter, t5);
        d.push(l2[2]);
      }
      for (const m of d) {
        if (!(m instanceof A))
          throw new t(e4, e.InvalidParameter, t5);
        {
          const n = m.hasField("name") ? m.field("name") : "", r2 = m.hasField("statistic") ? m.field("statistic") : "", s2 = m.hasField("expression") ? m.field("expression") : "";
          if (!n || !r2 || !s2)
            throw new t(e4, e.InvalidParameter, t5);
          u2.push({ name: n, statistic: r2.toLowerCase(), expression: f.create(s2, o2.getFieldsIndex()) });
        }
      }
      if (c3) {
        const e5 = {};
        for (const n of o2.fields)
          e5[n.name.toLowerCase()] = 1;
        for (const n of f3)
          "%%%%FIELDNAME" !== n.name && (e5[n.name.toLowerCase()] = 1);
        for (const n of u2)
          "%%%%FIELDNAME" !== n.name && (e5[n.name.toLowerCase()] = 1);
        let t6 = 0;
        for (const n of f3)
          if ("%%%%FIELDNAME" === n.name) {
            for (; 1 === e5["field_" + t6.toString()]; )
              t6++;
            e5["field_" + t6.toString()] = 1, n.name = "FIELD_" + t6.toString();
          }
      }
      for (const t6 of f3)
        await K(t6.expression, _, e4);
      for (const t6 of u2)
        await K(t6.expression, _, e4);
      return l2[0].groupby(f3, u2);
    });
  }, _.signatures.push({ name: "groupby", min: 3, max: 3 }), _.functions.distinct = function(e4, t5) {
    return _.standardFunctionAsync(e4, t5, async (r, s, l2) => {
      if (V(l2[0])) {
        Q(l2, 2, 2, e4, t5);
        const r2 = await l2[0].load(), s2 = [];
        let o2 = [];
        if (L(l2[1]))
          o2.push(l2[1]);
        else if (l2[1] instanceof A)
          o2.push(l2[1]);
        else if (z(l2[1]))
          o2 = l2[1];
        else {
          if (!q(l2[1]))
            throw new t(e4, e.InvalidParameter, t5);
          o2 = l2[1].toArray();
        }
        let f3 = false;
        for (const l3 of o2)
          if (L(l3)) {
            const e5 = f.create(oe(l3), r2.getFieldsIndex()), t6 = true === N(e5) ? oe(l3) : "%%%%FIELDNAME";
            s2.push({ name: t6, expression: e5 }), "%%%%FIELDNAME" === t6 && (f3 = true);
          } else {
            if (!(l3 instanceof A))
              throw new t(e4, e.InvalidParameter, t5);
            {
              const n = l3.hasField("name") ? l3.field("name") : "%%%%FIELDNAME", o3 = l3.hasField("expression") ? l3.field("expression") : "";
              if ("%%%%FIELDNAME" === n && (f3 = true), !n)
                throw new t(e4, e.InvalidParameter, t5);
              s2.push({ name: n, expression: f.create(o3 || n, r2.getFieldsIndex()) });
            }
          }
        if (f3) {
          const e5 = {};
          for (const n of r2.fields)
            e5[n.name.toLowerCase()] = 1;
          for (const n of s2)
            "%%%%FIELDNAME" !== n.name && (e5[n.name.toLowerCase()] = 1);
          let t6 = 0;
          for (const n of s2)
            if ("%%%%FIELDNAME" === n.name) {
              for (; 1 === e5["field_" + t6.toString()]; )
                t6++;
              e5["field_" + t6.toString()] = 1, n.name = "FIELD_" + t6.toString();
            }
        }
        for (const t6 of s2)
          await K(t6.expression, _, e4);
        return l2[0].groupby(s2, []);
      }
      return J("distinct", r, s, l2);
    });
  });
}
export {
  ae as registerFunctions
};
//# sourceMappingURL=featuresetbase-LTQDWQLB.js.map
