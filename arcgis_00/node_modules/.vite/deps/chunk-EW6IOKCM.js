import {
  O,
  s as s6
} from "./chunk-E3Y62DQE.js";
import {
  o as o3,
  u as u2
} from "./chunk-XR4HIGQP.js";
import {
  o as o2
} from "./chunk-4CZO65BK.js";
import {
  h
} from "./chunk-NZY6MEON.js";
import {
  d as d3,
  l as l2,
  t as t2
} from "./chunk-LWBXWNAZ.js";
import {
  t
} from "./chunk-2H7DV6BT.js";
import {
  n as n3
} from "./chunk-CSKEV5FZ.js";
import {
  n as n2
} from "./chunk-Z74XNIJ3.js";
import {
  n as n4,
  r as r2
} from "./chunk-GRS3EHGG.js";
import {
  E,
  S
} from "./chunk-Z6HMRH7V.js";
import {
  o
} from "./chunk-FUHI6TR6.js";
import {
  _ as _2
} from "./chunk-TLIPFBCN.js";
import {
  V
} from "./chunk-RNYFZDNI.js";
import {
  r2 as r
} from "./chunk-4X5MDDUC.js";
import {
  l,
  u2 as u
} from "./chunk-JLE6P4DW.js";
import {
  n
} from "./chunk-YVCC2Z32.js";
import {
  s as s5
} from "./chunk-VPF2CM6B.js";
import {
  m,
  y
} from "./chunk-TBBTJ7N4.js";
import {
  a2
} from "./chunk-AS7ITRBV.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  T,
  d
} from "./chunk-SF7FIURP.js";
import {
  $,
  _
} from "./chunk-TXAS6RAG.js";
import {
  d as d2,
  j,
  s as s4
} from "./chunk-G72U56FP.js";
import {
  s,
  s2,
  s3
} from "./chunk-JGYHKABU.js";
import {
  a
} from "./chunk-3FXB2ZFK.js";

// node_modules/@arcgis/core/support/basemapUtils.js
var c = s2.getLogger("esri.support.basemapUtils");
function o4() {
  return {};
}
function f(e3) {
  for (const r3 in e3) {
    const n5 = e3[r3];
    false === (n5 == null ? void 0 : n5.destroyed) && n5.destroy(), delete e3[r3];
  }
}
function p(n5, a4) {
  let t5;
  if ("string" == typeof n5) {
    if (!(n5 in s6)) {
      const e3 = Object.entries(s6).filter(([e4, n6]) => s.apiKey && !n6.classic || !s.apiKey && n6.classic && !n6.deprecated).map(([e4]) => `"${e4}"`).join(", ");
      return c.warn(`Unable to find basemap definition for: ${n5}. Try one of these: ${e3}`), null;
    }
    a4 && (t5 = a4[n5]), t5 || (t5 = O.fromId(n5), a4 && (a4[n5] = t5));
  } else
    t5 = d(O, n5);
  return (t5 == null ? void 0 : t5.destroyed) && (c.warn("The provided basemap is already destroyed", { basemap: t5 }), t5 = null), t5;
}
function h2(e3) {
  return !!(e3 == null ? void 0 : e3.baseLayers.concat(e3.referenceLayers).some(R));
}
function R(e3) {
  if (q(e3.url))
    return true;
  if ("vector-tile" === e3.type)
    for (const r3 in e3.sourceNameToSource) {
      const n5 = e3.sourceNameToSource[r3];
      if (q(n5 == null ? void 0 : n5.sourceUrl))
        return true;
    }
  return false;
}
function I(e3, r3) {
  var _a;
  if (null == r3 || null == e3)
    return { spatialReference: null, updating: false };
  if ("not-loaded" === r3.loadStatus)
    return r3.load(), { spatialReference: null, updating: true };
  if (r3.spatialReference)
    return { spatialReference: r3.spatialReference, updating: false };
  if (0 === r3.baseLayers.length)
    return { spatialReference: null, updating: false };
  const n5 = r3.baseLayers.at(0);
  switch (n5.loadStatus) {
    case "not-loaded":
      n5.load();
    case "loading":
      return { spatialReference: null, updating: true };
    case "failed":
      return { spatialReference: null, updating: false };
  }
  const a4 = (("supportedSpatialReferences" in n5 ? n5.supportedSpatialReferences : null) || ["tileInfo" in n5 ? (_a = n5.tileInfo) == null ? void 0 : _a.spatialReference : n5.spatialReference]).filter(Boolean), t5 = e3.spatialReference;
  return t5 ? { spatialReference: a4.find((e4) => t5.equals(e4)) ?? a4[0] ?? null, updating: false } : { spatialReference: a4[0], updating: false };
}
var T2 = /^(basemaps|ibasemaps).*-api\.arcgis\.com$/i;
function q(e3) {
  if (!e3)
    return false;
  const r3 = new $(_(e3));
  return !!r3.authority && T2.test(r3.authority);
}

// node_modules/@arcgis/core/ground/NavigationConstraint.js
var t3;
var p2 = t3 = class extends l {
  constructor(r3) {
    super(r3), this.type = "none";
  }
  clone() {
    return new t3({ type: this.type });
  }
};
e([o({ none: "none", stayAbove: "stay-above" })], p2.prototype, "type", void 0), p2 = t3 = e([a2("esri.ground.NavigationConstraint")], p2);

// node_modules/@arcgis/core/Ground.js
var C;
var S2 = C = class extends u(_2) {
  constructor(r3) {
    super(r3), this.opacity = 1, this.surfaceColor = null, this.navigationConstraint = null, this.layers = new V();
    const e3 = (r4) => {
      r4.parent && r4.parent !== this && "remove" in r4.parent && r4.parent.remove(r4), r4.parent = this, "elevation" !== r4.type && "base-elevation" !== r4.type && s2.getLogger(this).error(`Layer '${r4.title}, id:${r4.id}' of type '${r4.type}' is not supported as a ground layer and will therefore be ignored. Only layers of type 'elevation' are supported.`);
    }, t5 = (r4) => {
      r4.parent = null;
    };
    this.addHandles([this.layers.on("after-add", (r4) => e3(r4.item)), this.layers.on("after-remove", (r4) => t5(r4.item))]);
  }
  initialize() {
    this.when().catch((r3) => {
      d2(r3) || s2.getLogger(this).error("#load()", "Failed to load ground", r3);
    }), this.resourceInfo && this.read(this.resourceInfo.data, this.resourceInfo.context);
  }
  destroy() {
    const r3 = this.layers.removeAll();
    for (const e3 of r3)
      e3.destroy();
    this.layers.destroy();
  }
  normalizeCtorArgs(r3) {
    return r3 && "resourceInfo" in r3 && (this._set("resourceInfo", r3.resourceInfo), delete (r3 = { ...r3 }).resourceInfo), r3;
  }
  set layers(r3) {
    this._set("layers", n2(r3, this._get("layers")));
  }
  writeLayers(r3, e3, o5, t5) {
    const i3 = [];
    r3 ? (t5 = { ...t5, layerContainerType: "ground" }, r3.forEach((r4) => {
      if ("write" in r4) {
        const e4 = {};
        o2(r4)().write(e4, t5) && i3.push(e4);
      } else
        t5 && t5.messages && t5.messages.push(new s3("layer:unsupported", `Layers (${r4.title}, ${r4.id}) of type '${r4.declaredClass}' cannot be persisted in the ground`, { layer: r4 }));
    }), e3.layers = i3) : e3.layers = i3;
  }
  load(r3) {
    return this.addResolvingPromise(this._loadFromSource(r3)), Promise.resolve(this);
  }
  loadAll() {
    return t(this, (r3) => {
      r3(this.layers);
    });
  }
  async queryElevation(r3, e3) {
    await this.load({ signal: e3 == null ? void 0 : e3.signal });
    const { ElevationQuery: o5 } = await import("./ElevationQuery-X4CF6WM2.js");
    s4(e3);
    const t5 = new o5(), s7 = this.layers.filter(L).toArray();
    return t5.queryAll(s7, r3, e3);
  }
  async createElevationSampler(r3, e3) {
    await this.load({ signal: e3 == null ? void 0 : e3.signal });
    const { ElevationQuery: o5 } = await import("./ElevationQuery-X4CF6WM2.js");
    s4(e3);
    const t5 = new o5(), s7 = this.layers.filter(L).toArray();
    return t5.createSamplerAll(s7, r3, e3);
  }
  clone() {
    const r3 = { opacity: this.opacity, surfaceColor: a(this.surfaceColor), navigationConstraint: a(this.navigationConstraint), layers: this.layers.slice() };
    return this.loaded && (r3.loadStatus = "loaded"), new C({ resourceInfo: this.resourceInfo }).set(r3);
  }
  read(r3, e3) {
    this.resourceInfo || this._set("resourceInfo", { data: r3, context: e3 }), super.read(r3, e3);
  }
  _loadFromSource(r3) {
    const e3 = this.resourceInfo;
    return e3 ? this._loadLayersFromJSON(e3.data, e3.context, r3) : Promise.resolve();
  }
  _loadLayersFromJSON(r3, e3, o5) {
    const t5 = e3 && e3.origin || "web-scene", s7 = e3 && e3.portal || null, a4 = e3 && e3.url || null;
    return import("./layersCreator-KM6C74MA.js").then(({ populateOperationalLayers: e4 }) => {
      s4(o5);
      const i3 = [];
      if (r3.layers && Array.isArray(r3.layers)) {
        const o6 = { context: { origin: t5, url: a4, portal: s7, layerContainerType: "ground" }, defaultLayerType: "ArcGISTiledElevationServiceLayer" };
        i3.push(e4(this.layers, r3.layers, o6));
      }
      return j(i3);
    }).then(() => {
    });
  }
};
function I2(r3) {
  return r3 && "createElevationSampler" in r3;
}
function L(r3) {
  return "elevation" === r3.type || I2(r3);
}
e([y({ json: { read: false } })], S2.prototype, "layers", null), e([r("layers")], S2.prototype, "writeLayers", null), e([y({ readOnly: true })], S2.prototype, "resourceInfo", void 0), e([y({ type: Number, nonNullable: true, range: { min: 0, max: 1 }, json: { type: T, read: { reader: r2, source: "transparency" }, write: { writer: (r3, e3) => {
  e3.transparency = n4(r3);
}, target: "transparency" } } })], S2.prototype, "opacity", void 0), e([y({ type: h, json: { type: [T], write: (r3, e3) => {
  e3.surfaceColor = r3.toJSON().slice(0, 3);
} } })], S2.prototype, "surfaceColor", void 0), e([y({ type: p2, json: { write: true } })], S2.prototype, "navigationConstraint", void 0), S2 = C = e([a2("esri.Ground")], S2);
var A = S2;

// node_modules/@arcgis/core/layers/support/editableLayers.js
function e2(o5) {
  var _a, _b;
  return !(!(o5 && "object" == typeof o5 && "loaded" in o5 && o5.loaded && ((_b = (_a = E(o5)) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsEditing) && "type" in o5) || "editingEnabled" in o5 && !S(o5) || "scene" === o5.type && !i(o5));
}
function i(n5) {
  const r3 = n5.infoFor3D;
  if (!r3)
    return true;
  const { supportedFormats: e3, queryFormats: i3 } = r3, s7 = o3("model/gltf-binary", e3) ?? u2("glb", e3);
  return null != s7 && i3.includes(s7);
}

// node_modules/@arcgis/core/support/groundUtils.js
var i2 = { "world-elevation": { id: "worldElevation", url: "//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer", layerType: "ArcGISTiledElevationServiceLayer" }, "world-topobathymetry": { id: "worldTopoBathymetry", url: "//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/TopoBathy3D/ImageServer", layerType: "ArcGISTiledElevationServiceLayer" } };
function t4(t5) {
  let a4 = null;
  if ("string" == typeof t5)
    if (t5 in i2) {
      const r3 = i2[t5];
      a4 = new A({ resourceInfo: { data: { layers: [r3] } } });
    } else
      s2.getLogger("esri.support.groundUtils").warn(`Unable to find ground definition for: ${t5}. Try "world-elevation"`);
  else
    a4 = d(A, t5);
  return a4;
}

// node_modules/@arcgis/core/Map.js
var f2 = class extends l2(d3(n.EventedMixin(m))) {
  constructor(s7) {
    super(s7), this.allLayers = new n3({ getCollections: () => {
      var _a, _b, _c;
      return [(_a = this.basemap) == null ? void 0 : _a.baseLayers, (_b = this.ground) == null ? void 0 : _b.layers, this.layers, (_c = this.basemap) == null ? void 0 : _c.referenceLayers];
    }, getChildrenFunction: (s8) => "layers" in s8 ? s8.layers : null }), this.allTables = t2(this), this.basemap = null, this.editableLayers = new n3({ getCollections: () => [this.allLayers], itemFilterFunction: e2 }), this.ground = new A(), this._basemapCache = o4();
  }
  destroy() {
    var _a, _b;
    this.allLayers.destroy(), this.allTables.destroy(), this.editableLayers.destroy(), (_a = this.ground) == null ? void 0 : _a.destroy(), (_b = this.basemap) == null ? void 0 : _b.destroy(), f(this._basemapCache), this._basemapCache = null;
  }
  castBasemap(s7) {
    return p(s7, this._basemapCache);
  }
  castGround(s7) {
    const e3 = t4(s7);
    return e3 ?? this._get("ground");
  }
  findLayerById(s7) {
    return this.allLayers.find((e3) => e3.id === s7);
  }
  findTableById(s7) {
    return this.allTables.find((e3) => e3.id === s7);
  }
};
e([y({ readOnly: true, dependsOn: [] })], f2.prototype, "allLayers", void 0), e([y({ readOnly: true })], f2.prototype, "allTables", void 0), e([y({ type: O })], f2.prototype, "basemap", void 0), e([s5("basemap")], f2.prototype, "castBasemap", null), e([y({ readOnly: true })], f2.prototype, "editableLayers", void 0), e([y({ type: A, nonNullable: true })], f2.prototype, "ground", void 0), e([s5("ground")], f2.prototype, "castGround", null), f2 = e([a2("esri.Map")], f2);
var j2 = f2;

// node_modules/@arcgis/core/webmap/background/ColorBackground.js
var p3;
var a3 = p3 = class extends l {
  constructor(o5) {
    super(o5), this.color = new h([0, 0, 0, 1]);
  }
  clone() {
    return new p3(a({ color: this.color }));
  }
};
e([y({ type: h, json: { write: true } })], a3.prototype, "color", void 0), a3 = p3 = e([a2("esri.webmap.background.ColorBackground")], a3);
var m2 = a3;

export {
  h2 as h,
  R,
  I,
  j2 as j,
  m2 as m
};
//# sourceMappingURL=chunk-EW6IOKCM.js.map
