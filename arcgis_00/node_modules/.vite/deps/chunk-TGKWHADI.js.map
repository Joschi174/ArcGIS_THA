{
  "version": 3,
  "sources": ["../../@esri/calcite-components/dist/components/openCloseComponent.js"],
  "sourcesContent": ["/*!\r\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\r\n * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.\r\n * v1.9.2\r\n */\r\nimport { readTask } from '@stencil/core/internal/client/index.js';\r\n\r\nfunction isOpen(component) {\r\n  return \"opened\" in component ? component.opened : component.open;\r\n}\r\nfunction emitImmediately(component, nonOpenCloseComponent = false) {\r\n  (nonOpenCloseComponent ? component[component.transitionProp] : isOpen(component))\r\n    ? component.onBeforeOpen()\r\n    : component.onBeforeClose();\r\n  (nonOpenCloseComponent ? component[component.transitionProp] : isOpen(component))\r\n    ? component.onOpen()\r\n    : component.onClose();\r\n}\r\n/**\r\n * Helper to determine globally set transition duration on the given openTransitionProp, which is imported and set in the @Watch(\"open\").\r\n * Used to emit (before)open/close events both for when the opacity transition is present and when there is none (transition-duration is set to 0).\r\n *\r\n * @example\r\n * import { onToggleOpenCloseComponent, OpenCloseComponent } from \"../../utils/openCloseComponent\";\r\n *\r\n * async componentWillLoad() {\r\n * // When component initially renders, if `open` was set we need to trigger on load as watcher doesn't fire.\r\n * if (this.open) {\r\n *    onToggleOpenCloseComponent(this);\r\n * }\r\n * @Watch(\"open\")\r\n * async toggleModal(value: boolean): Promise<void> {\r\n *    onToggleOpenCloseComponent(this);\r\n * }\r\n *\r\n * @param component - OpenCloseComponent uses `open` prop to emit (before)open/close.\r\n * @param nonOpenCloseComponent - OpenCloseComponent uses `expanded` prop to emit (before)open/close.\r\n */\r\nfunction onToggleOpenCloseComponent(component, nonOpenCloseComponent = false) {\r\n  readTask(() => {\r\n    if (component.transitionEl) {\r\n      const { transitionDuration: allDurations, transitionProperty: allProps } = getComputedStyle(component.transitionEl);\r\n      const allTransitionDurationsArray = allDurations.split(\",\");\r\n      const allTransitionPropsArray = allProps.split(\",\");\r\n      const openTransitionPropIndex = allTransitionPropsArray.indexOf(component.openTransitionProp);\r\n      const transitionDuration = allTransitionDurationsArray[openTransitionPropIndex] ??\r\n        /* Safari will have a single transition value if multiple props share it,\r\n        so we fall back to it if there's no matching prop duration */\r\n        allTransitionDurationsArray[0];\r\n      if (transitionDuration === \"0s\") {\r\n        emitImmediately(component, nonOpenCloseComponent);\r\n        return;\r\n      }\r\n      const fallbackTimeoutId = setTimeout(() => {\r\n        component.transitionEl.removeEventListener(\"transitionstart\", onStart);\r\n        component.transitionEl.removeEventListener(\"transitionend\", onEndOrCancel);\r\n        component.transitionEl.removeEventListener(\"transitioncancel\", onEndOrCancel);\r\n        emitImmediately(component, nonOpenCloseComponent);\r\n      }, parseFloat(transitionDuration) * 1000);\r\n      component.transitionEl.addEventListener(\"transitionstart\", onStart);\r\n      component.transitionEl.addEventListener(\"transitionend\", onEndOrCancel);\r\n      component.transitionEl.addEventListener(\"transitioncancel\", onEndOrCancel);\r\n      function onStart(event) {\r\n        if (event.propertyName === component.openTransitionProp && event.target === component.transitionEl) {\r\n          clearTimeout(fallbackTimeoutId);\r\n          component.transitionEl.removeEventListener(\"transitionstart\", onStart);\r\n          (nonOpenCloseComponent ? component[component.transitionProp] : isOpen(component))\r\n            ? component.onBeforeOpen()\r\n            : component.onBeforeClose();\r\n        }\r\n      }\r\n      function onEndOrCancel(event) {\r\n        if (event.propertyName === component.openTransitionProp && event.target === component.transitionEl) {\r\n          (nonOpenCloseComponent ? component[component.transitionProp] : isOpen(component))\r\n            ? component.onOpen()\r\n            : component.onClose();\r\n          component.transitionEl.removeEventListener(\"transitionend\", onEndOrCancel);\r\n          component.transitionEl.removeEventListener(\"transitioncancel\", onEndOrCancel);\r\n        }\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nexport { onToggleOpenCloseComponent as o };\r\n"],
  "mappings": ";;;;;AAOA,SAAS,OAAO,WAAW;AACzB,SAAO,YAAY,YAAY,UAAU,SAAS,UAAU;AAC9D;AACA,SAAS,gBAAgB,WAAW,wBAAwB,OAAO;AACjE,GAAC,wBAAwB,UAAU,UAAU,cAAc,IAAI,OAAO,SAAS,KAC3E,UAAU,aAAa,IACvB,UAAU,cAAc;AAC5B,GAAC,wBAAwB,UAAU,UAAU,cAAc,IAAI,OAAO,SAAS,KAC3E,UAAU,OAAO,IACjB,UAAU,QAAQ;AACxB;AAqBA,SAAS,2BAA2B,WAAW,wBAAwB,OAAO;AAC5E,WAAS,MAAM;AACb,QAAI,UAAU,cAAc;AAsB1B,UAAS,UAAT,SAAiB,OAAO;AACtB,YAAI,MAAM,iBAAiB,UAAU,sBAAsB,MAAM,WAAW,UAAU,cAAc;AAClG,uBAAa,iBAAiB;AAC9B,oBAAU,aAAa,oBAAoB,mBAAmB,OAAO;AACrE,WAAC,wBAAwB,UAAU,UAAU,cAAc,IAAI,OAAO,SAAS,KAC3E,UAAU,aAAa,IACvB,UAAU,cAAc;AAAA,QAC9B;AAAA,MACF,GACS,gBAAT,SAAuB,OAAO;AAC5B,YAAI,MAAM,iBAAiB,UAAU,sBAAsB,MAAM,WAAW,UAAU,cAAc;AAClG,WAAC,wBAAwB,UAAU,UAAU,cAAc,IAAI,OAAO,SAAS,KAC3E,UAAU,OAAO,IACjB,UAAU,QAAQ;AACtB,oBAAU,aAAa,oBAAoB,iBAAiB,aAAa;AACzE,oBAAU,aAAa,oBAAoB,oBAAoB,aAAa;AAAA,QAC9E;AAAA,MACF;AAtCA,YAAM,EAAE,oBAAoB,cAAc,oBAAoB,SAAS,IAAI,iBAAiB,UAAU,YAAY;AAClH,YAAM,8BAA8B,aAAa,MAAM,GAAG;AAC1D,YAAM,0BAA0B,SAAS,MAAM,GAAG;AAClD,YAAM,0BAA0B,wBAAwB,QAAQ,UAAU,kBAAkB;AAC5F,YAAM,qBAAqB,4BAA4B,uBAAuB;AAAA;AAAA,MAG5E,4BAA4B,CAAC;AAC/B,UAAI,uBAAuB,MAAM;AAC/B,wBAAgB,WAAW,qBAAqB;AAChD;AAAA,MACF;AACA,YAAM,oBAAoB,WAAW,MAAM;AACzC,kBAAU,aAAa,oBAAoB,mBAAmB,OAAO;AACrE,kBAAU,aAAa,oBAAoB,iBAAiB,aAAa;AACzE,kBAAU,aAAa,oBAAoB,oBAAoB,aAAa;AAC5E,wBAAgB,WAAW,qBAAqB;AAAA,MAClD,GAAG,WAAW,kBAAkB,IAAI,GAAI;AACxC,gBAAU,aAAa,iBAAiB,mBAAmB,OAAO;AAClE,gBAAU,aAAa,iBAAiB,iBAAiB,aAAa;AACtE,gBAAU,aAAa,iBAAiB,oBAAoB,aAAa;AAAA,IAmB3E;AAAA,EACF,CAAC;AACH;",
  "names": []
}
