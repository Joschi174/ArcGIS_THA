import {
  g
} from "./chunk-SKUXQIFV.js";
import "./chunk-KH6IF2DR.js";
import {
  l as l3,
  m,
  s as s3,
  u as u2
} from "./chunk-FYOYPWJM.js";
import {
  K,
  N
} from "./chunk-DXR6YJWZ.js";
import "./chunk-DUKWKXVY.js";
import "./chunk-WDNVMLWG.js";
import "./chunk-T3UXUOZW.js";
import "./chunk-FLVP2XLK.js";
import {
  i as i2
} from "./chunk-LRYQNKYC.js";
import {
  l as l2
} from "./chunk-NOI4I5TT.js";
import {
  j as j3
} from "./chunk-M52YOZDN.js";
import {
  t as t2
} from "./chunk-VLY2K2HC.js";
import {
  c
} from "./chunk-AVOTXTN2.js";
import {
  O
} from "./chunk-4FGKBJP7.js";
import {
  d
} from "./chunk-LALFHQE3.js";
import "./chunk-IVCYO56U.js";
import "./chunk-JGFWZDK3.js";
import "./chunk-IN5QJ5F4.js";
import "./chunk-5IXGL4JZ.js";
import "./chunk-D76KSV7G.js";
import "./chunk-GRS3EHGG.js";
import "./chunk-TNYMHVJ4.js";
import "./chunk-Z6HMRH7V.js";
import "./chunk-JZBA2N4X.js";
import {
  b
} from "./chunk-4W4V5TBI.js";
import {
  i
} from "./chunk-HABV4VZ2.js";
import {
  Cn,
  Gn
} from "./chunk-2D2437VM.js";
import "./chunk-YIIAB4WA.js";
import "./chunk-KTSEQWMB.js";
import "./chunk-FUHI6TR6.js";
import "./chunk-FVYUULND.js";
import "./chunk-BRRN7CRU.js";
import "./chunk-TLIPFBCN.js";
import "./chunk-7KTXAH5E.js";
import "./chunk-WYE6B4VU.js";
import "./chunk-H7C32RFW.js";
import {
  V
} from "./chunk-RNYFZDNI.js";
import "./chunk-FBG4WSP5.js";
import "./chunk-G3X4SV7G.js";
import "./chunk-AJM6LB5B.js";
import "./chunk-G4LADD2B.js";
import "./chunk-HLTEFNTE.js";
import {
  j
} from "./chunk-CO3TM5QL.js";
import "./chunk-FARQZCLL.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-E5XSQEGK.js";
import "./chunk-MZXYP6SL.js";
import {
  r2 as r
} from "./chunk-4X5MDDUC.js";
import {
  o
} from "./chunk-UURR7HU3.js";
import {
  l,
  u2 as u
} from "./chunk-JLE6P4DW.js";
import "./chunk-5EXFDBQJ.js";
import {
  U,
  a as a3
} from "./chunk-F3SBJW2O.js";
import "./chunk-YVCC2Z32.js";
import "./chunk-YC3PYTAZ.js";
import "./chunk-46JSCFRH.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-VPF2CM6B.js";
import "./chunk-JCWF5RB4.js";
import {
  t2 as t,
  y
} from "./chunk-TBBTJ7N4.js";
import "./chunk-NUI5LCQ5.js";
import {
  a2,
  s2
} from "./chunk-AS7ITRBV.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-SF7FIURP.js";
import {
  j as j2
} from "./chunk-K7YQIZQM.js";
import "./chunk-H3ETM4DZ.js";
import {
  L
} from "./chunk-TXAS6RAG.js";
import {
  f
} from "./chunk-G72U56FP.js";
import "./chunk-DWOEYHKS.js";
import {
  s3 as s
} from "./chunk-JGYHKABU.js";
import {
  a
} from "./chunk-3FXB2ZFK.js";
import "./chunk-WQNVH5M4.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/SceneModification.js
var m2;
var y2 = m2 = class extends l {
  constructor(e2) {
    super(e2), this.geometry = null, this.type = "clip";
  }
  writeGeometry(e2, r2, o2, s4) {
    if (s4.layer && s4.layer.spatialReference && !s4.layer.spatialReference.equals(this.geometry.spatialReference)) {
      if (!Cn(e2.spatialReference, s4.layer.spatialReference))
        return void (s4 && s4.messages && s4.messages.push(new s2("scenemodification:unsupported", "Scene modifications with incompatible spatial references are not supported", { modification: this, spatialReference: s4.layer.spatialReference, context: s4 })));
      const p = new j();
      Gn(e2, p, s4.layer.spatialReference), r2[o2] = p.toJSON(s4);
    } else
      r2[o2] = e2.toJSON(s4);
    delete r2[o2].spatialReference;
  }
  clone() {
    return new m2({ geometry: a(this.geometry), type: this.type });
  }
};
e([y({ type: j }), g()], y2.prototype, "geometry", void 0), e([r(["web-scene", "portal-item"], "geometry")], y2.prototype, "writeGeometry", null), e([y({ type: ["clip", "mask", "replace"], nonNullable: true }), g()], y2.prototype, "type", void 0), y2 = m2 = e([a2("esri.layers.support.SceneModification")], y2);
var f2 = y2;

// node_modules/@arcgis/core/layers/support/SceneModifications.js
var a4;
var n = a4 = class extends u(V.ofType(f2)) {
  constructor(r2) {
    super(r2), this.url = null;
  }
  clone() {
    return new a4({ url: this.url, items: this.items.map((r2) => r2.clone()) });
  }
  toJSON(r2) {
    return this.toArray().map((o2) => o2.toJSON(r2)).filter((r3) => !!r3.geometry);
  }
  static fromJSON(r2, o2) {
    const t3 = new a4();
    for (const e2 of r2)
      t3.add(f2.fromJSON(e2, o2));
    return t3;
  }
  static async fromUrl(r2, t3, e2) {
    const i3 = { url: L(r2), origin: "service" }, c2 = await j2(r2, { responseType: "json", signal: e2 == null ? void 0 : e2.signal }), n2 = t3.toJSON(), m4 = [];
    for (const o2 of c2.data)
      m4.push(f2.fromJSON({ ...o2, geometry: { ...o2.geometry, spatialReference: n2 } }, i3));
    return new a4({ url: r2, items: m4 });
  }
};
e([y({ type: String })], n.prototype, "url", void 0), n = a4 = e([a2("esri.layers.support.SceneModifications")], n);
var m3 = n;

// node_modules/@arcgis/core/layers/IntegratedMeshLayer.js
var I = class extends N(l2(c(j3(t2(O(i2(b))))))) {
  constructor(...e2) {
    super(...e2), this._handles = new t(), this.geometryType = "mesh", this.operationalLayerType = "IntegratedMeshLayer", this.type = "integrated-mesh", this.nodePages = null, this.materialDefinitions = null, this.textureSetDefinitions = null, this.geometryDefinitions = null, this.serviceUpdateTimeStamp = null, this.profile = "mesh-pyramids", this.modifications = null, this._modificationsSource = null, this.elevationInfo = null, this.path = null;
  }
  destroy() {
    this._handles.destroy();
  }
  initialize() {
    this._handles.add(a3(() => this.modifications, "after-changes", () => this.modifications = this.modifications, U));
  }
  normalizeCtorArgs(e2, t3) {
    return "string" == typeof e2 ? { url: e2, ...t3 } : e2;
  }
  readModifications(e2, t3, r2) {
    this._modificationsSource = { url: i(e2, r2), context: r2 };
  }
  async load(e2) {
    return this.addResolvingPromise(this._doLoad(e2)), this;
  }
  async _doLoad(e2) {
    const t3 = e2 == null ? void 0 : e2.signal;
    try {
      await this.loadFromPortal({ supportedTypes: ["Scene Service"] }, e2);
    } catch (r2) {
      f(r2);
    }
    if (await this._fetchService(t3), null != this._modificationsSource) {
      const t4 = await m3.fromUrl(this._modificationsSource.url, this.spatialReference, e2);
      this.setAtOrigin("modifications", t4, this._modificationsSource.context.origin), this._modificationsSource = null;
    }
    await this._fetchIndexAndUpdateExtent(this.nodePages, t3);
  }
  beforeSave() {
    if (null != this._modificationsSource)
      return this.load().then(() => {
      }, () => {
      });
  }
  async saveAs(e2, t3) {
    return this._debouncedSaveOperations(K.SAVE_AS, { ...t3, getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "integrated-mesh" }, e2);
  }
  async save() {
    const e2 = { getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "integrated-mesh" };
    return this._debouncedSaveOperations(K.SAVE, e2);
  }
  validateLayer(e2) {
    if (e2.layerType && "IntegratedMesh" !== e2.layerType)
      throw new s("integrated-mesh-layer:layer-type-not-supported", "IntegratedMeshLayer does not support this layer type", { layerType: e2.layerType });
    if (isNaN(this.version.major) || isNaN(this.version.minor))
      throw new s("layer:service-version-not-supported", "Service version is not supported.", { serviceVersion: this.version.versionString, supportedVersions: "1.x" });
    if (this.version.major > 1)
      throw new s("layer:service-version-too-new", "Service version is too new.", { serviceVersion: this.version.versionString, supportedVersions: "1.x" });
  }
  _getTypeKeywords() {
    return ["IntegratedMeshLayer"];
  }
};
e([y({ type: String, readOnly: true })], I.prototype, "geometryType", void 0), e([y({ type: ["show", "hide"] })], I.prototype, "listMode", void 0), e([y({ type: ["IntegratedMeshLayer"] })], I.prototype, "operationalLayerType", void 0), e([y({ json: { read: false }, readOnly: true })], I.prototype, "type", void 0), e([y({ type: s3, readOnly: true })], I.prototype, "nodePages", void 0), e([y({ type: [l3], readOnly: true })], I.prototype, "materialDefinitions", void 0), e([y({ type: [u2], readOnly: true })], I.prototype, "textureSetDefinitions", void 0), e([y({ type: [m], readOnly: true })], I.prototype, "geometryDefinitions", void 0), e([y({ readOnly: true })], I.prototype, "serviceUpdateTimeStamp", void 0), e([y({ type: m3 }), g({ origins: ["web-scene", "portal-item"], type: "resource", prefix: "modifications" })], I.prototype, "modifications", void 0), e([o(["web-scene", "portal-item"], "modifications")], I.prototype, "readModifications", null), e([y(d)], I.prototype, "elevationInfo", void 0), e([y({ type: String, json: { origins: { "web-scene": { read: true, write: true }, "portal-item": { read: true, write: true } }, read: false } })], I.prototype, "path", void 0), I = e([a2("esri.layers.IntegratedMeshLayer")], I);
var O2 = I;
export {
  O2 as default
};
//# sourceMappingURL=IntegratedMeshLayer-UBTXUVPM.js.map
