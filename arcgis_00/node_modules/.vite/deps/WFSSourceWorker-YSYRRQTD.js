import {
  H
} from "./chunk-HVZZRFW4.js";
import "./chunk-PODY5IF6.js";
import {
  I,
  T
} from "./chunk-I2KJQQFJ.js";
import {
  d as d3
} from "./chunk-ZGRKHQBF.js";
import {
  m
} from "./chunk-G6EUXULQ.js";
import "./chunk-KNZXZHW6.js";
import {
  ee
} from "./chunk-CCP2U3LF.js";
import "./chunk-LLQHB2ZB.js";
import "./chunk-MZ5UMPWK.js";
import {
  f,
  g
} from "./chunk-OARQV2FW.js";
import "./chunk-C4L2TGDU.js";
import "./chunk-325OL72R.js";
import {
  rt,
  st
} from "./chunk-EIIX6MK3.js";
import "./chunk-WTKN55TU.js";
import "./chunk-TDPKDZC3.js";
import "./chunk-M5UHI5WR.js";
import "./chunk-N4TMSSSQ.js";
import "./chunk-M7JVCLZD.js";
import "./chunk-SCLBEJO3.js";
import "./chunk-QZX72TAQ.js";
import "./chunk-5CJTGLZW.js";
import "./chunk-SO7CVIZK.js";
import "./chunk-FJYIB7HF.js";
import "./chunk-R6YWR46K.js";
import "./chunk-PT3MUKWE.js";
import "./chunk-GZTLZ6RD.js";
import "./chunk-4HDCOJ24.js";
import "./chunk-VY2MIGMV.js";
import {
  r
} from "./chunk-BA7WNJMF.js";
import "./chunk-ZZQVVHF7.js";
import "./chunk-C4I3X4RM.js";
import "./chunk-GVMBTEIW.js";
import "./chunk-XMS7FYO7.js";
import "./chunk-TNYMHVJ4.js";
import "./chunk-OZXJDVTE.js";
import {
  d as d2
} from "./chunk-JZBA2N4X.js";
import "./chunk-2D2437VM.js";
import "./chunk-YIIAB4WA.js";
import "./chunk-KTSEQWMB.js";
import "./chunk-FUHI6TR6.js";
import "./chunk-G3X4SV7G.js";
import "./chunk-AJM6LB5B.js";
import "./chunk-G4LADD2B.js";
import "./chunk-HLTEFNTE.js";
import "./chunk-CO3TM5QL.js";
import "./chunk-FARQZCLL.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-E5XSQEGK.js";
import "./chunk-MZXYP6SL.js";
import {
  S2 as S,
  p
} from "./chunk-4X5MDDUC.js";
import "./chunk-UURR7HU3.js";
import "./chunk-JLE6P4DW.js";
import "./chunk-F3SBJW2O.js";
import "./chunk-YVCC2Z32.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-46JSCFRH.js";
import "./chunk-VPF2CM6B.js";
import "./chunk-JCWF5RB4.js";
import "./chunk-TBBTJ7N4.js";
import "./chunk-NUI5LCQ5.js";
import "./chunk-AS7ITRBV.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-SF7FIURP.js";
import "./chunk-K7YQIZQM.js";
import "./chunk-H3ETM4DZ.js";
import "./chunk-TXAS6RAG.js";
import {
  d,
  s as s3
} from "./chunk-G72U56FP.js";
import "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-JGYHKABU.js";
import "./chunk-3FXB2ZFK.js";
import "./chunk-WQNVH5M4.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/graphics/sources/WFSSourceWorker.js
var d4 = class {
  constructor() {
    this._queryEngine = null, this._customParameters = null, this._snapshotFeatures = async (e) => {
      const { objectIdField: t } = this._queryEngine, r2 = await H(this._getFeatureUrl ?? "", this._featureType.typeName, this._getFeatureOutputFormat, { customParameters: this._customParameters, dateFields: this._queryEngine.fieldsIndex.dateFields.map((e2) => e2.name), signal: e });
      await T(r2), s3(e);
      const a = I(r2, { geometryType: this._queryEngine.geometryType, hasZ: false, objectIdField: t });
      if (!S(this._queryEngine.spatialReference, p))
        for (const s4 of a)
          null != s4.geometry && (s4.geometry = rt(g(st(s4.geometry, this._queryEngine.geometryType, false, false), p, this._queryEngine.spatialReference)));
      let p2 = 1;
      for (const s4 of a) {
        const e2 = {};
        d3(this._fieldsIndex, e2, s4.attributes, true), s4.attributes = e2, null == s4.attributes[t] && (s4.objectId = s4.attributes[t] = p2++);
      }
      return a;
    };
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = null;
  }
  async load(e, t) {
    const { getFeatureUrl: r2, getFeatureOutputFormat: a, spatialReference: i, fields: n, geometryType: o, featureType: u, objectIdField: h, customParameters: y } = e;
    this._featureType = u, this._customParameters = y, this._getFeatureUrl = r2, this._getFeatureOutputFormat = a, this._fieldsIndex = new r(n), await this._checkProjection(i), s3(t), this._queryEngine = new ee({ fields: n, geometryType: o, hasM: false, hasZ: false, objectIdField: h, spatialReference: i, timeInfo: null, featureStore: new m({ geometryType: o, hasM: false, hasZ: false }) });
    const l = await this._snapshotFeatures(t.signal);
    return this._queryEngine.featureStore.addMany(l), { extent: (await this._queryEngine.fetchRecomputedExtents()).fullExtent };
  }
  async applyEdits() {
    throw new s2("wfs-source:editing-not-supported", "applyEdits() is not supported on WFSLayer");
  }
  async queryFeatures(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t.signal);
  }
  async queryFeatureCount(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t.signal);
  }
  async queryObjectIds(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e, t.signal);
  }
  async queryExtent(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t.signal);
  }
  async querySnapping(e, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e, t.signal);
  }
  async refresh(s4) {
    var _a;
    return this._customParameters = s4, (_a = this._snapshotTask) == null ? void 0 : _a.abort(), this._snapshotTask = d2(this._snapshotFeatures), this._snapshotTask.promise.then((e) => {
      this._queryEngine.featureStore.clear(), e && this._queryEngine.featureStore.addMany(e);
    }, (e) => {
      this._queryEngine.featureStore.clear(), d(e) || s.getLogger("esri.layers.WFSLayer").error(new s2("wfs-layer:getfeature-error", "An error occurred during the GetFeature request", { error: e }));
    }), await this._waitSnapshotComplete(), { extent: (await this._queryEngine.fetchRecomputedExtents()).fullExtent };
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _checkProjection(e) {
    try {
      await f(p, e);
    } catch {
      throw new s2("unsupported-projection", "Projection not supported", { spatialReference: e });
    }
  }
};
export {
  d4 as default
};
//# sourceMappingURL=WFSSourceWorker-YSYRRQTD.js.map
