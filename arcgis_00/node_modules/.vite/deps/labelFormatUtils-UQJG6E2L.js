import {
  _,
  x
} from "./chunk-DDZ6WPWX.js";
import {
  c as c2,
  se
} from "./chunk-TNYMHVJ4.js";
import "./chunk-G3X4SV7G.js";
import "./chunk-AJM6LB5B.js";
import "./chunk-HLTEFNTE.js";
import "./chunk-CO3TM5QL.js";
import "./chunk-FARQZCLL.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-E5XSQEGK.js";
import "./chunk-MZXYP6SL.js";
import "./chunk-4X5MDDUC.js";
import "./chunk-UURR7HU3.js";
import "./chunk-JLE6P4DW.js";
import {
  M,
  c2 as c,
  f
} from "./chunk-CL7UAIKB.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-VPF2CM6B.js";
import "./chunk-JCWF5RB4.js";
import "./chunk-TBBTJ7N4.js";
import "./chunk-NUI5LCQ5.js";
import "./chunk-AS7ITRBV.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-SF7FIURP.js";
import "./chunk-G72U56FP.js";
import "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-JGYHKABU.js";
import "./chunk-3FXB2ZFK.js";
import "./chunk-WQNVH5M4.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/labelFormatUtils.js
var s3 = s.getLogger("esri.layers.support.labelFormatUtils");
var c3 = { type: "simple", evaluate: () => null };
var f2 = { getAttribute: (e, r) => e.field(r) };
async function p(r, t, n) {
  if (!r || !r.symbol || !t)
    return c3;
  const a = r.where, o = x(r), p2 = a ? await import("./WhereClause-J4K2OEOO.js") : null;
  let m;
  if ("arcade" === o.type) {
    const r2 = await c2(o.expression, n, t);
    if (null == r2)
      return c3;
    m = { type: "arcade", evaluate(t2) {
      try {
        const e = r2.evaluate({ $feature: "attributes" in t2 ? r2.repurposeFeature(t2) : t2 }, r2.services);
        if (null != e)
          return e.toString();
      } catch (n2) {
        s3.error(new s2("arcade-expression-error", "Encountered an error when evaluating label expression for feature", { error: n2, feature: t2, expression: o }));
      }
      return null;
    }, needsHydrationToEvaluate: () => null == _(o.expression) };
  } else
    m = { type: "simple", evaluate: (e) => o.expression.replaceAll(/{[^}]*}/g, (r2) => {
      const n2 = r2.slice(1, -1), a2 = t.get(n2);
      if (!a2)
        return r2;
      let o2 = null;
      if ("attributes" in e) {
        e && e.attributes && (o2 = e.attributes[a2.name]);
      } else
        o2 = e.field(a2.name);
      return null == o2 ? "" : d(o2, a2);
    }) };
  if (a) {
    let r2;
    try {
      r2 = p2.WhereClause.create(a, t);
    } catch (g) {
      return s3.error(new s2("bad-where-clause", "Encountered an error when evaluating where clause, ignoring", { where: a, error: g })), c3;
    }
    const n2 = m.evaluate;
    m.evaluate = (t2) => {
      const o2 = "attributes" in t2 ? void 0 : f2;
      try {
        if (r2.testFeature(t2, o2))
          return n2(t2);
      } catch (g) {
        s3.error(new s2("bad-where-clause", "Encountered an error when evaluating where clause for feature", { where: a, feature: t2, error: g }));
      }
      return null;
    };
  }
  return m;
}
function d(e, r) {
  if (null == e)
    return "";
  const l = r.domain;
  if (l) {
    if ("codedValue" === l.type || "coded-value" === l.type) {
      const r2 = e;
      for (const e2 of l.codedValues)
        if (e2.code === r2)
          return e2.name;
    } else if ("range" === l.type) {
      const r2 = +e, t = "range" in l ? l.range[0] : l.minValue, n = "range" in l ? l.range[1] : l.maxValue;
      if (t <= r2 && r2 <= n)
        return l.name;
    }
  }
  let i = e;
  return "date" === r.type || "esriFieldTypeDate" === r.type ? i = f(i, M("short-date")) : se(r) && (i = c(+i)), i || "";
}
export {
  p as createLabelFunction,
  d as formatField
};
//# sourceMappingURL=labelFormatUtils-UQJG6E2L.js.map
