import {
  E,
  a as a3,
  n as n2,
  o,
  x
} from "./chunk-BQJY56X4.js";
import "./chunk-4XXKLC7H.js";
import "./chunk-NVZXNBIH.js";
import {
  i
} from "./chunk-K6D7DQGC.js";
import "./chunk-CN3PB7HS.js";
import "./chunk-SQZ7ON7Z.js";
import "./chunk-ZL3HOHNK.js";
import "./chunk-DSVPEX7K.js";
import "./chunk-PX3Q44FM.js";
import "./chunk-XYJMHUDA.js";
import "./chunk-CSLWFQJE.js";
import "./chunk-PR2OEILG.js";
import {
  p as p2
} from "./chunk-XP6ESZGI.js";
import "./chunk-JKPERUTC.js";
import "./chunk-A4HFWKMU.js";
import "./chunk-TDXHXKUI.js";
import {
  p
} from "./chunk-JWBL7PFU.js";
import "./chunk-BBJLFBMQ.js";
import "./chunk-AZ4FK2MA.js";
import "./chunk-EULDPA4O.js";
import "./chunk-IVABPLLZ.js";
import {
  S
} from "./chunk-TBHRKIAA.js";
import "./chunk-FF5LS3YE.js";
import "./chunk-BCDDCNQ2.js";
import "./chunk-M5UHI5WR.js";
import "./chunk-R6HT3QM2.js";
import "./chunk-QOWAKGE4.js";
import "./chunk-5CJTGLZW.js";
import "./chunk-D4SJZ5KN.js";
import "./chunk-A7XI44IB.js";
import "./chunk-R7L5PZPI.js";
import "./chunk-QNFDBY7V.js";
import "./chunk-EL72ISXP.js";
import "./chunk-5KLICR5E.js";
import "./chunk-CKSC27NP.js";
import "./chunk-OVFWVPXL.js";
import "./chunk-WNYS35QN.js";
import "./chunk-VFUAVCAY.js";
import "./chunk-X4Y5OF5X.js";
import {
  a as a2,
  s as s2
} from "./chunk-LKYCF7AI.js";
import "./chunk-FHYNSVC4.js";
import "./chunk-R5EWWIOD.js";
import "./chunk-ZZQVVHF7.js";
import "./chunk-6L4U2AW6.js";
import "./chunk-7C7EF3FD.js";
import "./chunk-PQOGMOZ7.js";
import "./chunk-XMS7FYO7.js";
import "./chunk-HOGRNOD4.js";
import "./chunk-NZY6MEON.js";
import "./chunk-Z74XNIJ3.js";
import "./chunk-GRS3EHGG.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-EIE3W25Z.js";
import "./chunk-TNYMHVJ4.js";
import "./chunk-OZXJDVTE.js";
import "./chunk-Z6HMRH7V.js";
import "./chunk-HABV4VZ2.js";
import "./chunk-FUHI6TR6.js";
import "./chunk-BRRN7CRU.js";
import "./chunk-TLIPFBCN.js";
import "./chunk-7KTXAH5E.js";
import "./chunk-WYE6B4VU.js";
import "./chunk-X5ASTC4J.js";
import "./chunk-3OL5L3LC.js";
import "./chunk-RNYFZDNI.js";
import "./chunk-G3X4SV7G.js";
import "./chunk-AJM6LB5B.js";
import "./chunk-G4LADD2B.js";
import "./chunk-HLTEFNTE.js";
import "./chunk-CO3TM5QL.js";
import "./chunk-FARQZCLL.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-E5XSQEGK.js";
import "./chunk-MZXYP6SL.js";
import {
  f
} from "./chunk-4X5MDDUC.js";
import "./chunk-UURR7HU3.js";
import "./chunk-JLE6P4DW.js";
import "./chunk-F3SBJW2O.js";
import "./chunk-YVCC2Z32.js";
import "./chunk-YC3PYTAZ.js";
import "./chunk-46JSCFRH.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-VPF2CM6B.js";
import "./chunk-JCWF5RB4.js";
import "./chunk-TBBTJ7N4.js";
import "./chunk-NUI5LCQ5.js";
import {
  a2 as a
} from "./chunk-AS7ITRBV.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-SF7FIURP.js";
import "./chunk-K7YQIZQM.js";
import "./chunk-H3ETM4DZ.js";
import "./chunk-TXAS6RAG.js";
import {
  d,
  s
} from "./chunk-G72U56FP.js";
import {
  n,
  u
} from "./chunk-DWOEYHKS.js";
import "./chunk-JGYHKABU.js";
import "./chunk-3FXB2ZFK.js";
import "./chunk-WQNVH5M4.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/2d/layers/features/support/ResourceManagerProxy.js
var t = class {
  constructor(e2) {
    this._remoteClient = e2, this._resourceMap = /* @__PURE__ */ new Map(), this._inFlightResourceMap = /* @__PURE__ */ new Map(), this.geometryEngine = null, this.geometryEnginePromise = null;
  }
  destroy() {
  }
  async fetchResource(t2, r) {
    const s3 = this._resourceMap, i2 = s3.get(t2);
    if (i2)
      return i2;
    let n3 = this._inFlightResourceMap.get(t2);
    if (n3)
      return n3;
    try {
      n3 = this._remoteClient.invoke("tileRenderer.fetchResource", { url: t2 }, { ...r }), this._inFlightResourceMap.set(t2, n3), n3.then((e2) => (this._inFlightResourceMap.delete(t2), s3.set(t2, e2), e2));
    } catch (o2) {
      return d(o2) ? null : { width: 0, height: 0 };
    }
    return n3;
  }
  getResource(e2) {
    return this._resourceMap.get(e2) ?? null;
  }
  loadFont(e2) {
    return Promise.resolve(null);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processors/SymbolProcessor.js
function b(e2, t2) {
  return (!e2.minScale || e2.minScale >= t2) && (!e2.maxScale || e2.maxScale <= t2);
}
function S2(e2) {
  const t2 = e2.message, r = { message: { data: {}, tileKey: t2.tileKey, tileKeyOrigin: t2.tileKeyOrigin, version: t2.version }, transferList: new Array() };
  for (const i2 in t2.data) {
    const e3 = i2, a4 = t2.data[e3];
    if (r.message.data[e3] = null, null != a4) {
      const t3 = a4.stride, i3 = a4.indices.slice(0), o2 = a4.vertices.slice(0), n3 = a4.records.slice(0), l = { stride: t3, indices: i3, vertices: o2, records: n3, metrics: n(a4.metrics, (e4) => e4.slice(0)) };
      r.transferList.push(i3, o2, n3), r.message.data[e3] = l;
    }
  }
  return r;
}
var w = class extends p {
  constructor() {
    super(...arguments), this.type = "symbol", this._matchers = { feature: null, aggregate: null }, this._bufferData = /* @__PURE__ */ new Map(), this._bufferIds = /* @__PURE__ */ new Map();
  }
  initialize() {
    this.handles.add([this.tileStore.on("update", this.onTileUpdate.bind(this))]), this._resourceManagerProxy = new t(this.remoteClient);
  }
  destroy() {
    this._resourceManagerProxy.destroy();
  }
  get supportsTileUpdates() {
    return true;
  }
  forEachBufferId(e2) {
    this._bufferIds.forEach((t2) => {
      t2.forEach(e2);
    });
  }
  async update(e2, t2) {
    var _a;
    const s3 = t2.schema.processors[0];
    if ("symbol" !== s3.type)
      return;
    const r = a2(this._schema, s3);
    (s2(r, "mesh") || s2(r, "target")) && (e2.mesh = true, (_a = e2.why) == null ? void 0 : _a.mesh.push("Symbology changed"), this._schema = s3, this._factory = this._createFactory(s3), this._factory.update(s3, this.tileStore.tileScheme.tileInfo));
  }
  onTileMessage(e2, t2, s3, r) {
    return s(r), this._onTileData(e2, t2, s3, r);
  }
  onTileClear(e2, t2) {
    const s3 = { clear: true, end: t2 };
    return this._bufferData.delete(e2.key.id), this._bufferIds.delete(e2.key.id), this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e2.id, data: s3 });
  }
  onTileError(e2, t2, s3) {
    const r = s3.signal, i2 = { tileKey: e2.id, error: t2 };
    return this.remoteClient.invoke("tileRenderer.onTileError", i2, { signal: r });
  }
  onTileUpdate(e2) {
    for (const t2 of e2.removed)
      this._bufferData.has(t2.key.id) && this._bufferData.delete(t2.key.id), this._bufferIds.has(t2.key.id) && this._bufferIds.delete(t2.key.id);
    for (const t2 of e2.added)
      this._bufferData.forEach((e3) => {
        for (const s3 of e3)
          s3.message.tileKey === t2.id && this._updateTileMesh("append", t2, S2(s3), [], false, false, null);
      });
  }
  _addBufferData(e2, t2) {
    var _a;
    this._bufferData.has(e2) || this._bufferData.set(e2, []), (_a = this._bufferData.get(e2)) == null ? void 0 : _a.push(S2(t2));
  }
  _createFactory(e2) {
    const { geometryType: t2, objectIdField: r, fields: i2 } = this.service, a4 = (e3, t3) => this.remoteClient.invoke("tileRenderer.getMaterialItems", e3, t3), o2 = { geometryType: t2, fields: i2, spatialReference: f.fromJSON(this.spatialReference) }, n3 = new x(a4, this.tileStore.tileScheme.tileInfo), { matcher: l, aggregateMatcher: d2 } = e2.mesh;
    return this._store = n3, this._matchers.feature = o(l, n3, o2, this._resourceManagerProxy), this._matchers.aggregate = n(d2, (e3) => o(e3, n3, o2, this._resourceManagerProxy)), new a3(t2, r, n3);
  }
  async _onTileData(e2, t2, s3, r) {
    var _a;
    s(r);
    const { type: a4, addOrUpdate: o2, remove: n3, clear: l, end: c } = t2, d2 = !!this._schema.mesh.sortKey;
    if (!o2) {
      const t3 = { type: a4, addOrUpdate: null, remove: n3, clear: l, end: c, sort: d2 };
      return this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e2.id, data: t3 }, r);
    }
    const h = this._processFeatures(e2, o2, s3, r, (_a = t2.status) == null ? void 0 : _a.version);
    try {
      const s4 = await h;
      if (null == s4) {
        const t3 = { type: a4, addOrUpdate: null, remove: n3, clear: l, end: c, sort: d2 };
        return this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e2.id, data: t3 }, r);
      }
      const i2 = [];
      for (const t3 of s4) {
        let s5 = false;
        const r2 = t3.message.bufferIds, a5 = e2.key.id, o3 = t3.message.tileKey;
        if (a5 !== o3 && null != r2) {
          if (!this.tileStore.get(o3)) {
            this._addBufferData(a5, t3), i2.push(t3);
            continue;
          }
          let e3 = this._bufferIds.get(o3);
          e3 || (e3 = /* @__PURE__ */ new Set(), this._bufferIds.set(o3, e3));
          const n4 = Array.from(r2);
          for (const t4 of n4) {
            if (e3.has(t4)) {
              s5 = true;
              break;
            }
            e3.add(t4);
          }
        }
        s5 || (this._addBufferData(a5, t3), i2.push(t3));
      }
      await Promise.all(i2.map((s5) => {
        const i3 = e2.key.id === s5.message.tileKey, o3 = i3 ? t2.remove : [], n4 = i3 && t2.end;
        return this._updateTileMesh(a4, e2, s5, o3, n4, !!t2.clear, r.signal);
      }));
    } catch (f2) {
      this._handleError(e2, f2, r);
    }
  }
  async _updateTileMesh(e2, t2, r, a4, o2, n3, l) {
    const c = e2, d2 = r.message.tileKey, h = !!this._schema.mesh.sortKey;
    d2 !== t2.key.id && (o2 = false);
    const f2 = { type: c, addOrUpdate: n(r, (e3) => e3.message), remove: a4, clear: n3, end: o2, sort: h }, u2 = { transferList: n(r, (e3) => e3.transferList) || [], signal: l };
    return s(u2), this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: d2, data: f2 }, u2);
  }
  async _processFeatures(e2, t2, s3, r, a4) {
    if (null == t2 || !t2.hasFeatures)
      return null;
    const o2 = { transform: e2.transform, hasZ: false, hasM: false }, n3 = this._factory, l = { viewingMode: "", scale: e2.scale }, c = await this._matchers.feature, d2 = await this._matchers.aggregate;
    s(r);
    const h = this._getLabelInfos(e2, t2);
    return await n3.analyze(t2.getCursor(), this._resourceManagerProxy, c, d2, o2, l), s(r), this._writeFeatureSet(e2, t2, o2, h, n3, s3, a4);
  }
  _writeFeatureSet(e2, t2, s3, r, i2, a4, o2) {
    const n3 = t2.getSize(), l = this._schema.mesh.matcher.symbologyType, c = new E(e2.key.id, { features: n3, records: n3, metrics: 0 }, l, a4, l !== S.HEATMAP, o2), d2 = { viewingMode: "", scale: e2.scale }, u2 = t2.getCursor();
    for (; u2.next(); )
      try {
        const t3 = u2.getDisplayId(), a5 = null != r ? r.get(t3) : null;
        i2.writeCursor(c, u2, s3, d2, e2.level, a5, this._resourceManagerProxy);
      } catch (g) {
      }
    const m = e2.tileInfoView.tileInfo.isWrappable;
    return c.serialize(m);
  }
  _handleError(e2, t2, s3) {
    if (!d(t2)) {
      const r = { tileKey: e2.id, error: t2.message };
      return this.remoteClient.invoke("tileRenderer.onTileError", r, { signal: s3.signal });
    }
    return Promise.resolve();
  }
  _getLabelingSchemaForScale(e2) {
    const t2 = this._schema.mesh.labels;
    if (null == t2)
      return null;
    if ("subtype" === t2.type) {
      const s4 = { type: "subtype", classes: {} };
      let r = false;
      for (const i2 in t2.classes) {
        const a4 = t2.classes[i2].filter((t3) => b(t3, e2.scale));
        r = r || !!a4.length, s4.classes[i2] = a4;
      }
      return r ? s4 : null;
    }
    const s3 = t2.classes.filter((t3) => b(t3, e2.scale));
    return s3.length ? { type: "simple", classes: s3 } : null;
  }
  _getLabels(e2, t2) {
    if ("subtype" === t2.type) {
      const s3 = this.service.subtypeField, i2 = u(s3, "Expected to find subtype Field"), a4 = e2.readAttribute(i2);
      return null == a4 ? [] : t2.classes[a4] ?? [];
    }
    return t2.classes;
  }
  _getLabelInfos(e2, s3) {
    const r = this._getLabelingSchemaForScale(e2);
    if (null == r)
      return null;
    const i2 = /* @__PURE__ */ new Map(), a4 = s3.getCursor();
    for (; a4.next(); ) {
      const e3 = a4.getDisplayId(), s4 = [], o2 = p2(e3), n3 = o2 && 1 !== a4.readAttribute("cluster_count") ? "aggregate" : "feature", l = this._getLabels(a4, r);
      for (const r2 of l) {
        if (r2.target !== n3)
          continue;
        const i3 = a4.getStorage(), l2 = o2 && "feature" === n3 ? i3.getComputedStringAtIndex(a4.readAttribute("referenceId"), r2.fieldIndex) : i3.getComputedStringAtIndex(e3, r2.fieldIndex);
        if (!l2)
          continue;
        const c = i(l2.toString()), d2 = c[0], h = c[1];
        this._store.getMosaicItem(r2.symbol, n2(d2)).then((e4) => {
          s4[r2.index] = { glyphs: e4.glyphMosaicItems ?? [], rtl: h, index: r2.index };
        });
      }
      i2.set(e3, s4);
    }
    return i2;
  }
};
w = e([a("esri.views.2d.layers.features.processors.SymbolProcessor")], w);
var I = w;
export {
  I as default
};
//# sourceMappingURL=SymbolProcessor-2O5NKRV4.js.map
