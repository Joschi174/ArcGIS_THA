import {
  e as e3,
  e2 as e4,
  f2,
  f3,
  l,
  l2,
  n,
  n3 as n2,
  o as o2,
  o2 as o3,
  o3 as o4,
  o4 as o5,
  r as r4
} from "./chunk-ULIETMI3.js";
import {
  t as t2
} from "./chunk-F5ZHI6OR.js";
import "./chunk-CP22CCY6.js";
import {
  g as g2,
  p
} from "./chunk-C6NFHKR7.js";
import {
  c as c2,
  c2 as c3,
  m as m2
} from "./chunk-2SQERXEW.js";
import {
  e
} from "./chunk-ERPBUHHC.js";
import "./chunk-JDLUEEG6.js";
import {
  D
} from "./chunk-WD6NUK3A.js";
import {
  q
} from "./chunk-EJFHVDPI.js";
import "./chunk-P7XUSZ33.js";
import "./chunk-5AH5IDTK.js";
import "./chunk-7ZHPCAJ3.js";
import {
  f,
  i as i2,
  o,
  t
} from "./chunk-GIISDD7O.js";
import "./chunk-2DDLBIQJ.js";
import "./chunk-EFWZWJ5X.js";
import "./chunk-4JI25WEU.js";
import {
  e as e2
} from "./chunk-MJUOK6OE.js";
import {
  E,
  L,
  O,
  T,
  c,
  i,
  u,
  x
} from "./chunk-ARQKL4BE.js";
import "./chunk-IIHBYDIT.js";
import {
  r as r3
} from "./chunk-TEW7IDMC.js";
import "./chunk-OLJLBTGU.js";
import {
  g
} from "./chunk-WHFPT3MI.js";
import "./chunk-Z7ID6LQT.js";
import "./chunk-HFKPIUEB.js";
import {
  h
} from "./chunk-7XK4IPKN.js";
import "./chunk-3S6PFVBD.js";
import "./chunk-A7HIXRLM.js";
import "./chunk-IJCLSAKS.js";
import "./chunk-PDYDTTO6.js";
import "./chunk-Y2UHC2VM.js";
import "./chunk-7APSGFF5.js";
import "./chunk-S5RFXGTW.js";
import "./chunk-V2A2K5J6.js";
import "./chunk-WNCSTS7O.js";
import "./chunk-JU2JBJRJ.js";
import "./chunk-CBBETCDS.js";
import {
  _,
  m
} from "./chunk-D3IA7B5F.js";
import {
  r as r2
} from "./chunk-RKDN5PXO.js";
import "./chunk-UILB2BFY.js";
import "./chunk-U4PYQFWE.js";
import "./chunk-FNONMLXB.js";
import "./chunk-7KNADJUA.js";
import "./chunk-NMXESCE4.js";
import "./chunk-O6HKLIZS.js";
import "./chunk-DNUHV7J4.js";
import "./chunk-RRCNLKGG.js";
import "./chunk-RJHZ4FSH.js";
import "./chunk-DUGCD7YI.js";
import "./chunk-3CMERT4A.js";
import "./chunk-ZQWMLUHC.js";
import "./chunk-G5A25MBN.js";
import {
  r
} from "./chunk-7LFT2RDJ.js";
import {
  j
} from "./chunk-QPWNDO2C.js";
import "./chunk-CA2PXGXL.js";
import "./chunk-RXTTOJU7.js";
import "./chunk-4HAMAX2C.js";
import "./chunk-3QT5L2OK.js";
import "./chunk-5QASCMFT.js";
import "./chunk-GHZEFXB4.js";
import "./chunk-5G3YEFQP.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/chunks/mat32.js
function e5(e7, t6, r6) {
  const o8 = e7.typedBuffer, d = e7.typedBufferStride, f4 = t6.typedBuffer, n3 = t6.typedBufferStride, c4 = r6 ? r6.count : t6.count;
  let u3 = (r6 && r6.dstIndex ? r6.dstIndex : 0) * d, l3 = (r6 && r6.srcIndex ? r6.srcIndex : 0) * n3;
  for (let p2 = 0; p2 < c4; ++p2) {
    for (let e8 = 0; e8 < 9; ++e8)
      o8[u3 + e8] = f4[l3 + e8];
    u3 += d, l3 += n3;
  }
}
var t3 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e5 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/mat42.js
function e6(e7, t6, r6) {
  const o8 = e7.typedBuffer, d = e7.typedBufferStride, f4 = t6.typedBuffer, n3 = t6.typedBufferStride, c4 = r6 ? r6.count : t6.count;
  let u3 = (r6 && r6.dstIndex ? r6.dstIndex : 0) * d, l3 = (r6 && r6.srcIndex ? r6.srcIndex : 0) * n3;
  for (let p2 = 0; p2 < c4; ++p2) {
    for (let e8 = 0; e8 < 16; ++e8)
      o8[u3 + e8] = f4[l3 + e8];
    u3 += d, l3 += n3;
  }
}
var t4 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e6 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/geometry/support/buffer/utils.js
function r5(s, r6) {
  return new s(new ArrayBuffer(r6 * s.ElementCount * e(s.ElementType)));
}

// node_modules/@arcgis/core/geometry/support/meshUtils/loadGLTFMesh.js
async function N(e7, t6, r6) {
  const o8 = { ...r6, useTransform: (r6 == null ? void 0 : r6.useTransform) ?? true }, n3 = new n2(z(o8)), s = (await l2(n3, t6, o8, true)).model, a = s.lods.shift(), l3 = /* @__PURE__ */ new Map(), i3 = /* @__PURE__ */ new Map();
  s.textures.forEach((e8, t7) => l3.set(t7, H(e8))), s.materials.forEach((e8, t7) => i3.set(t7, J(e8, l3)));
  const u3 = Q(a);
  for (const p2 of u3.parts)
    W(u3, p2, i3);
  const { position: c4, normal: f4, tangent: m3, color: d, texCoord0: g3 } = u3.vertexAttributes, x2 = { position: c4.typedBuffer, normal: null != f4 ? f4.typedBuffer : null, tangent: null != m3 ? m3.typedBuffer : null, uv: null != g3 ? g3.typedBuffer : null, color: null != d ? d.typedBuffer : null }, T2 = q(x2, e7, o8);
  return { transform: T2.transform, vertexSpace: T2.vertexSpace, components: u3.components, spatialReference: e7.spatialReference, vertexAttributes: new p({ position: T2.vertexAttributes.position, normal: T2.vertexAttributes.normal, tangent: T2.vertexAttributes.tangent, color: x2.color, uv: x2.uv }) };
}
function z(e7) {
  const r6 = e7 == null ? void 0 : e7.resolveFile;
  return r6 ? { busy: false, request: async (e8, o8, n3) => {
    const s = r6(e8), a = "image" === o8 ? "image" : "binary" === o8 ? "array-buffer" : "json";
    return (await j(s, { responseType: a, signal: null != n3 ? n3.signal : null })).data;
  } } : null;
}
function G(e7, t6) {
  if (null == e7)
    return "-";
  const o8 = e7.typedBuffer;
  return `${r(t6, o8.buffer, () => t6.size)}/${o8.byteOffset}/${o8.byteLength}`;
}
function K(e7) {
  return null != e7 ? e7.toString() : "-";
}
function Q(e7) {
  let t6 = 0;
  const has = { color: false, tangent: false, normal: false, texCoord0: false }, o8 = /* @__PURE__ */ new Map(), n3 = /* @__PURE__ */ new Map(), s = [];
  for (const a of e7.parts) {
    const { attributes: { position: e8, normal: l3, color: i3, tangent: u3, texCoord0: c4 } } = a, f4 = `
      ${G(e8, o8)}/
      ${G(l3, o8)}/
      ${G(i3, o8)}/
      ${G(u3, o8)}/
      ${G(c4, o8)}/
      ${K(a.transform)}
    `;
    let m3 = false;
    const p2 = r(n3, f4, () => (m3 = true, { start: t6, length: e8.count }));
    m3 && (t6 += e8.count), l3 && (has.normal = true), i3 && (has.color = true), u3 && (has.tangent = true), c4 && (has.texCoord0 = true), s.push({ gltf: a, writeVertices: m3, region: p2 });
  }
  return { vertexAttributes: { position: r5(T, t6), normal: has.normal ? r5(i, t6) : null, tangent: has.tangent ? r5(c, t6) : null, color: has.color ? r5(x, t6) : null, texCoord0: has.texCoord0 ? r5(u, t6) : null }, parts: s, components: [] };
}
function H(e7) {
  return new m2({ data: (t2(e7.data), e7.data), wrap: Z(e7.parameters.wrap) });
}
function J(t6, r6) {
  const o8 = new h(re(t6.color, t6.opacity)), s = t6.emissiveFactor ? new h(oe(t6.emissiveFactor)) : null, a = (e7) => e7 ? new c2({ scale: e7.scale ? [e7.scale[0], e7.scale[1]] : [1, 1], rotation: m(e7.rotation ?? 0), offset: e7.offset ? [e7.offset[0], e7.offset[1]] : [0, 0] }) : null;
  return new c3({ color: o8, colorTexture: r6.get(t6.textureColor), normalTexture: r6.get(t6.textureNormal), emissiveColor: s, emissiveTexture: r6.get(t6.textureEmissive), occlusionTexture: r6.get(t6.textureOcclusion), alphaMode: Y(t6.alphaMode), alphaCutoff: t6.alphaCutoff, doubleSided: t6.doubleSided, metallic: t6.metallicFactor, roughness: t6.roughnessFactor, metallicRoughnessTexture: r6.get(t6.textureMetallicRoughness), colorTextureTransform: a(t6.colorTextureTransform), normalTextureTransform: a(t6.normalTextureTransform), occlusionTextureTransform: a(t6.occlusionTextureTransform), emissiveTextureTransform: a(t6.emissiveTextureTransform), metallicRoughnessTextureTransform: a(t6.metallicRoughnessTextureTransform) });
}
function W(e7, t6, r6) {
  t6.writeVertices && X(e7, t6);
  const { indices: o8, attributes: n3, primitiveType: s, material: a } = t6.gltf;
  let l3 = o4(o8 || n3.position.count, s);
  const i3 = t6.region.start;
  if (i3) {
    const e8 = new Uint32Array(l3);
    for (let t7 = 0; t7 < l3.length; t7++)
      e8[t7] += i3;
    l3 = e8;
  }
  e7.components.push(new g2({ faces: l3, material: r6.get(a), shading: n3.normal ? "source" : "flat", trustSourceNormals: true }));
}
function X(e7, t6) {
  const { position: r6, normal: n3, tangent: l3, color: i3, texCoord0: u3 } = e7.vertexAttributes, c4 = t6.region.start, { attributes: f4, transform: m3 } = t6.gltf, p2 = f4.position.count;
  if (t(r6.slice(c4, p2), f4.position, m3), null != f4.normal && null != n3) {
    const e8 = g(e2(), m3), t7 = n3.slice(c4, p2);
    f(t7, f4.normal, e8), _(e8) && i2(t7, t7);
  } else
    null != n3 && f2(n3, 0, 0, 1, { dstIndex: c4, count: p2 });
  if (null != f4.tangent && null != l3) {
    const e8 = g(e2(), m3), t7 = l3.slice(c4, p2);
    r4(t7, f4.tangent, e8), _(e8) && n(t7, t7);
  } else
    null != l3 && f3(l3, 0, 0, 1, 1, { dstIndex: c4, count: p2 });
  if (null != f4.texCoord0 && null != u3 ? o3(u3.slice(c4, p2), f4.texCoord0) : null != u3 && l(u3, 0, 0, { dstIndex: c4, count: p2 }), null != f4.color && null != i3) {
    const e8 = f4.color, t7 = i3.slice(c4, p2);
    if (4 === e8.elementCount)
      e8 instanceof c ? o2(t7, e8, 255) : e8 instanceof x ? e4(t7, e8) : e8 instanceof L && o2(t7, e8, 1 / 256);
    else {
      f3(t7, 255, 255, 255, 255);
      const r7 = O.fromTypedArray(t7.typedBuffer, t7.typedBufferStride);
      e8 instanceof i ? o(r7, e8, 255) : e8 instanceof O ? e3(r7, e8) : e8 instanceof E && o(r7, e8, 1 / 256);
    }
  } else
    null != i3 && f3(i3.slice(c4, p2), 255, 255, 255, 255);
}
function Y(e7) {
  switch (e7) {
    case "OPAQUE":
      return "opaque";
    case "MASK":
      return "mask";
    case "BLEND":
      return "blend";
  }
}
function Z(e7) {
  return { horizontal: ee(e7.s), vertical: ee(e7.t) };
}
function ee(e7) {
  switch (e7) {
    case D.CLAMP_TO_EDGE:
      return "clamp";
    case D.MIRRORED_REPEAT:
      return "mirror";
    case D.REPEAT:
      return "repeat";
  }
}
function te(e7) {
  return e7 ** (1 / o5) * 255;
}
function re(e7, t6) {
  return r3(te(e7[0]), te(e7[1]), te(e7[2]), t6);
}
function oe(e7) {
  return r2(te(e7[0]), te(e7[1]), te(e7[2]));
}
export {
  N as loadGLTFMesh
};
//# sourceMappingURL=loadGLTFMesh-VEKZCLYB.js.map
