import {
  p as p3
} from "./chunk-5NZWHNTA.js";
import {
  a as a2
} from "./chunk-VS5PVM6T.js";
import {
  c as c2
} from "./chunk-O2ZWDZHR.js";
import {
  t as t2
} from "./chunk-7XISENE4.js";
import {
  Be
} from "./chunk-OCKZY4KB.js";
import {
  l as l2
} from "./chunk-GVRDPBQU.js";
import {
  b
} from "./chunk-BY57CSP7.js";
import {
  O
} from "./chunk-4FGKBJP7.js";
import {
  h
} from "./chunk-RFIIU6XF.js";
import {
  p as p2
} from "./chunk-D76KSV7G.js";
import {
  o as o2
} from "./chunk-FUHI6TR6.js";
import {
  x
} from "./chunk-FVYUULND.js";
import {
  _
} from "./chunk-TLIPFBCN.js";
import {
  t
} from "./chunk-5XLKQQPP.js";
import {
  p
} from "./chunk-HLTEFNTE.js";
import {
  M
} from "./chunk-E5XSQEGK.js";
import {
  f
} from "./chunk-4X5MDDUC.js";
import {
  l,
  u2 as u
} from "./chunk-JLE6P4DW.js";
import {
  o,
  s as s3
} from "./chunk-JCWF5RB4.js";
import {
  m,
  y
} from "./chunk-TBBTJ7N4.js";
import {
  a2 as a
} from "./chunk-AS7ITRBV.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  j
} from "./chunk-K7YQIZQM.js";
import {
  L
} from "./chunk-TXAS6RAG.js";
import {
  c,
  d
} from "./chunk-G72U56FP.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-JGYHKABU.js";

// node_modules/@arcgis/core/layers/support/featureQueryAll.js
async function r(e4, r2, a6) {
  r2 = r2.clone(), e4.capabilities.query.supportsMaxRecordCountFactor && (r2.maxRecordCountFactor = u2(e4));
  const n4 = t3(e4), o3 = e4.capabilities.query.supportsPagination;
  r2.start = 0, r2.num = n4;
  let i2 = null;
  for (; ; ) {
    const t4 = await e4.source.queryFeaturesJSON(r2, a6);
    if (null == i2 ? i2 = t4 : i2.features = i2.features.concat(t4.features), i2.exceededTransferLimit = t4.exceededTransferLimit, !o3 || !t4.exceededTransferLimit)
      break;
    r2.start += n4;
  }
  return i2;
}
function t3(e4) {
  return u2(e4) * a3(e4);
}
function a3(e4) {
  return e4.capabilities.query.maxRecordCount || 2e3;
}
function u2(r2) {
  return r2.capabilities.query.supportsMaxRecordCountFactor ? b.MAX_MAX_RECORD_COUNT_FACTOR : 1;
}

// node_modules/@arcgis/core/networks/support/TopologyValidationJobInfo.js
var n = o()({ Pending: "job-waiting", InProgress: "job-executing", Completed: "job-succeeded" });
var p4 = class extends p3 {
  constructor(t4) {
    super(t4), this.statusUrl = null, this.status = null, this.submissionTime = null, this.lastUpdatedTime = null, this._timer = void 0;
  }
  destroy() {
    clearInterval(this._timer);
  }
  async checkJobStatus(t4) {
    const s6 = { ...t4, query: { f: "json" } }, { data: r2 } = await j(this.statusUrl, s6);
    return this.read(r2), this.editsResolver && this.editsResolver.resolve({ edits: null, addedFeatures: [], updatedFeatures: [], deletedFeatures: [], addedAttachments: [], updatedAttachments: [], deletedAttachments: [], exceededTransferLimit: true }), this;
  }
  async waitForJobCompletion(t4 = {}) {
    const { interval: e4 = 1e3, statusCallback: s6 } = t4;
    return new Promise((t5, o3) => {
      this._clearTimer();
      const i2 = setInterval(() => {
        this._timer || o3(c()), this.checkJobStatus().then((e5) => {
          const { status: r2 } = e5;
          switch (this.status = r2, r2) {
            case "job-succeeded":
              this._clearTimer(), t5(this);
              break;
            case "job-waiting":
            case "job-executing":
              s6 && s6(this);
          }
        }, (t6) => {
          this._clearTimer(), o3(t6);
        });
      }, e4);
      this._timer = i2;
    });
  }
  _clearTimer() {
    clearInterval(this._timer), this._timer = void 0;
  }
};
e([y()], p4.prototype, "editsResolver", void 0), e([y({ type: String, json: { write: true } })], p4.prototype, "statusUrl", void 0), e([o2(n)], p4.prototype, "status", void 0), e([y({ type: Date, json: { type: Number, write: { writer: (t4, e4) => {
  e4.submissionTime = t4 ? t4.getTime() : null;
} } } })], p4.prototype, "submissionTime", void 0), e([y({ type: Date, json: { type: Number, write: { writer: (t4, e4) => {
  e4.lastUpdatedTime = t4 ? t4.getTime() : null;
} } } })], p4.prototype, "lastUpdatedTime", void 0), p4 = e([a("esri.networks.support.TopologyValidationJobInfo")], p4);
var l3 = p4;

// node_modules/@arcgis/core/networks/support/utils.js
async function s4(e4, t4) {
  if ("Utility Network Layer" === e4) {
    const { default: e5 } = await import("./UtilityNetwork-USYGAWZ6.js");
    return new e5({ layerUrl: t4 });
  }
  return null;
}
async function i(r2) {
  let a6 = "portalItem" in r2 ? r2 : { portalItem: r2 };
  !a6.portalItem || a6.portalItem instanceof x || (a6 = { ...a6, portalItem: new x(a6.portalItem) });
  const n4 = a6.portalItem;
  if (await n4.load(), "Feature Service" !== n4.type)
    throw new s2("portal:unknown-item-type", "Unknown item type '${type}'", { type: n4.type });
  const l5 = n4.url, i2 = await j(l5, { responseType: "json", query: { f: "json" } }), u4 = "Network Layer";
  if (i2.data.type && i2.data.type.includes(u4))
    return s4(i2.data.type, l5);
  if (i2.data.layers) {
    const e4 = i2.data.layers.find((e5) => e5.type.includes(u4));
    if (e4) {
      const t4 = `${l5}/${e4.id}`;
      return s4(e4.type, t4);
    }
  }
  return null;
}

// node_modules/@arcgis/core/rest/networks/support/QueryNamedTraceConfigurationsParameters.js
var e2 = class extends l {
  constructor(r2) {
    super(r2), this.globalIds = [], this.creators = [], this.tags = [], this.names = [];
  }
};
e([y({ type: [String], json: { write: true } })], e2.prototype, "globalIds", void 0), e([y({ type: [String], json: { write: true } })], e2.prototype, "creators", void 0), e([y({ type: [String], json: { write: true } })], e2.prototype, "tags", void 0), e([y({ type: [String], json: { write: true } })], e2.prototype, "names", void 0), e2 = e([a("esri.rest.networks.support.QueryNamedTraceConfigurationsParameters")], e2);
var p5 = e2;

// node_modules/@arcgis/core/networks/Network.js
var v = class extends O(_) {
  static fromPortalItem(e4) {
    return i(e4);
  }
  constructor(e4) {
    super(e4), this.id = null, this.title = null, this.layerUrl = null, this.dataElement = null, this.fullExtent = null, this.spatialReference = null, this.type = null, this.sourceJSON = null;
  }
  initialize() {
    this.when().catch((e4) => {
      d(e4) || s.getLogger(this).error("#load()", `Failed to load layer (title: '${this.title ?? "no title"}', id: '${this.id ?? "no id"}')`, { error: e4 });
    });
  }
  get datasetName() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.name) ?? null;
  }
  get owner() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.userIdentity) ?? null;
  }
  get schemaGeneration() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.schemaGeneration) ?? null;
  }
  get parsedUrl() {
    return L(this.layerUrl);
  }
  get featureServiceUrl() {
    var _a, _b;
    const e4 = p2((_a = this.parsedUrl) == null ? void 0 : _a.path);
    return ((_b = e4 == null ? void 0 : e4.url) == null ? void 0 : _b.path) ?? null;
  }
  get networkServiceUrl() {
    return this.featureServiceUrl ? this.featureServiceUrl.replace(/\/FeatureServer/i, "/UtilityNetworkServer") : null;
  }
  get layerId() {
    const e4 = this.parsedUrl && p2(this.parsedUrl.path);
    return null != e4 ? e4.sublayer : null;
  }
  get networkSystemLayers() {
    return null;
  }
  async load(e4) {
    return this.addResolvingPromise(this._fetchDataElement(this.featureServiceUrl, this.layerId.toString(), e4)), this.addResolvingPromise(this._fetchLayerMetaData(this.layerUrl, e4)), this;
  }
  getLayerIdBySourceId(e4) {
    if (this.dataElement) {
      const t4 = this.dataElement.domainNetworks;
      for (const r2 of t4) {
        for (const t5 of r2.edgeSources ?? [])
          if (t5.sourceId === e4)
            return t5.layerId;
        for (const t5 of r2.junctionSources ?? [])
          if (t5.sourceId === e4)
            return t5.layerId;
      }
      return null;
    }
    return null;
  }
  async queryNamedTraceConfigurations(e4, t4) {
    var _a;
    const { queryNamedTraceConfigurations: r2 } = await import("./queryNamedTraceConfigurations-OGXXYTOE.js"), o3 = this.networkServiceUrl, a6 = new p5({ ...e4 });
    return ((_a = await r2(o3, a6, { ...t4 })) == null ? void 0 : _a.namedTraceConfigurations) ?? null;
  }
  async validateTopology(e4, t4) {
    var _a, _b, _c;
    if (!e4.validateArea)
      throw new s2("network:undefined-validateArea", "the network must have validateArea defined in the validate network topology parameters.");
    const [{ validateNetworkTopology: r2 }, { default: a6 }] = await Promise.all([import("./validateNetworkTopology-6MOKPL6S.js"), import("./ValidateNetworkTopologyParameters-LT7CGRCE.js")]), s6 = a6.from(e4), i2 = this.networkServiceUrl, n4 = this.featureServiceUrl, l5 = l2(n4, null, true), d3 = await r2(i2, s6, { ...t4 });
    if (d3 == null ? void 0 : d3.serviceEdits) {
      const e5 = [];
      for (const t5 of d3.serviceEdits) {
        const { editedFeatures: r3 } = t5, o3 = (r3 == null ? void 0 : r3.spatialReference) ? new f(r3.spatialReference) : null;
        e5.push({ layerId: t5.layerId, editedFeatures: { adds: ((_a = r3 == null ? void 0 : r3.adds) == null ? void 0 : _a.map((e6) => this._createEditedFeature(e6, o3))) || [], updates: ((_b = r3 == null ? void 0 : r3.updates) == null ? void 0 : _b.map((e6) => ({ original: this._createEditedFeature(e6[0], o3), current: this._createEditedFeature(e6[1], o3) }))) || [], deletes: ((_c = r3 == null ? void 0 : r3.deletes) == null ? void 0 : _c.map((e6) => this._createEditedFeature(e6, o3))) || [], spatialReference: o3 } });
      }
      l5.resolve({ edits: null, addedFeatures: [], updatedFeatures: [], deletedFeatures: [], addedAttachments: [], updatedAttachments: [], deletedAttachments: [], editedFeatures: e5, exceededTransferLimit: false });
    }
    return d3;
  }
  async submitTopologyValidationJob(e4, t4) {
    if (!e4.validateArea)
      throw new s2("network:undefined-validateArea", "the network must have validateArea defined in the validate network topology parameters.");
    if (!e4.gdbVersion)
      throw new s2("network:undefined-gdb-version", "version must be defined");
    const [{ submitValidateNetworkTopologyJob: r2 }, { default: a6 }] = await Promise.all([import("./validateNetworkTopology-6MOKPL6S.js"), import("./ValidateNetworkTopologyParameters-LT7CGRCE.js")]), s6 = a6.from(e4), i2 = this.networkServiceUrl, n4 = this.featureServiceUrl ? l2(this.featureServiceUrl, null, true) : void 0, l5 = await r2(i2, s6, { ...t4 });
    return new l3({ statusUrl: l5, editsResolver: n4 });
  }
  _createEditedFeature(e4, r2) {
    return new h({ attributes: e4.attributes, geometry: p({ ...e4.geometry, spatialReference: r2 }) });
  }
  async _fetchLayerMetaData(e4, t4) {
    const o3 = await j(e4, { responseType: "json", query: { f: "json" }, ...t4 });
    this.sourceJSON = o3.data, this.read(o3.data, { origin: "service" });
  }
  async _fetchDataElement(e4, t4, o3) {
    if (this.dataElement)
      return;
    const a6 = await j(`${e4}/queryDataElements`, { responseType: "json", query: { layers: JSON.stringify([t4]), f: "json" }, ...o3 }).then((e5) => {
      var _a;
      return (_a = e5.data.layerDataElements) == null ? void 0 : _a[0];
    });
    a6 && this.read(a6, { origin: "service" });
  }
};
e([y({ type: String, nonNullable: true, json: { origins: { "web-map": { read: true, write: { isRequired: true } }, service: { read: true } }, read: false } })], v.prototype, "id", void 0), e([y({ type: String, nonNullable: true, json: { origins: { "web-map": { read: true, write: { isRequired: true } }, service: { read: { source: "name" } } }, read: false } })], v.prototype, "title", void 0), e([y({ type: String, nonNullable: true, json: { origins: { "web-map": { read: { source: "url" }, write: { target: "url", isRequired: true } } }, read: false } })], v.prototype, "layerUrl", void 0), e([y({ type: Object, json: { origins: { service: { read: true } }, read: false } })], v.prototype, "dataElement", void 0), e([y({ type: M, json: { origins: { service: { read: { source: "extent" } } }, read: false } })], v.prototype, "fullExtent", void 0), e([y({ type: f, json: { origins: { service: { read: { source: "extent.spatialReference" } } }, read: false } })], v.prototype, "spatialReference", void 0), e([y({ type: ["utility", "trace"], readOnly: true, json: { read: false, write: false } })], v.prototype, "type", void 0), e([y({ readOnly: true })], v.prototype, "datasetName", null), e([y({ readOnly: true })], v.prototype, "owner", null), e([y({ readOnly: true })], v.prototype, "schemaGeneration", null), e([y({ readOnly: true })], v.prototype, "parsedUrl", null), e([y({ readOnly: true })], v.prototype, "featureServiceUrl", null), e([y({ readOnly: true })], v.prototype, "networkServiceUrl", null), e([y({ readOnly: true })], v.prototype, "layerId", null), e([y()], v.prototype, "sourceJSON", void 0), e([y({ readOnly: true })], v.prototype, "networkSystemLayers", null), v = e([a("esri.networks.Network")], v);
var j2 = v;

// node_modules/@arcgis/core/networks/RulesTable.js
var a4 = class extends u(_) {
  constructor(e4) {
    super(e4), this.request = j;
  }
  initialize() {
  }
  async load(e4) {
    const t4 = this.layer.load(e4).then(() => this._initializeRulesTable());
    return this.addResolvingPromise(t4), this;
  }
  getFeatureSQL(e4, t4) {
    var _a, _b;
    const s6 = e4.layerId.toString(), o3 = (_a = e4.fieldsIndex) == null ? void 0 : _a.normalizeFieldName("assetGroup"), r2 = (_b = e4.fieldsIndex) == null ? void 0 : _b.normalizeFieldName("assetType"), n4 = o3 ? t4.attributes[o3] : null, i2 = r2 ? t4.attributes[r2] : null, a6 = this.rulesHash[s6];
    if (a6) {
      const e5 = a6.assetGroupHash[n4];
      if (e5) {
        return e5.assetTypeHash[i2] || null;
      }
    }
    return null;
  }
  async _initializeRulesTable() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    const e4 = {};
    let t4;
    !function(e5) {
      e5[e5.from = 0] = "from", e5[e5.to = 1] = "to", e5[e5.via = 2] = "via";
    }(t4 || (t4 = {}));
    const s6 = [{ networkSourceId: "fromNetworkSource", assetGroupId: "fromAssetGroup", assetTypeId: "fromAssetType" }, { networkSourceId: "toNetworkSource", assetGroupId: "toAssetGroup", assetTypeId: "toAssetType" }, { networkSourceId: "viaNetworkSource", assetGroupId: "viaAssetGroup", assetTypeId: "viaAssetType" }];
    for (const o3 of this.rules) {
      if (o3.ruleType !== t2.RTJunctionJunctionConnectivity && o3.ruleType !== t2.RTJunctionEdgeConnectivity && o3.ruleType !== t2.RTEdgeJunctionEdgeConnectivity)
        continue;
      let r2 = [[t4.from, t4.to], [t4.to, t4.from]];
      o3.ruleType === t2.RTEdgeJunctionEdgeConnectivity && (r2 = [[t4.from, t4.via], [t4.via, t4.from], [t4.to, t4.via], [t4.via, t4.to]]);
      for (const n4 of r2) {
        const r3 = n4.shift(), a6 = n4.shift();
        let u4 = false;
        switch (o3.ruleType) {
          case t2.RTEdgeJunctionEdgeConnectivity:
            u4 = r3 === t4.from || r3 === t4.to;
            break;
          case t2.RTJunctionEdgeConnectivity:
            u4 = r3 === t4.to;
        }
        const c3 = s6[r3], p9 = ((_a = o3[c3.networkSourceId]) == null ? void 0 : _a.layerId.toString()) ?? "", d3 = (_c = (_b = o3[c3.assetGroupId]) == null ? void 0 : _b.assetGroupCode) == null ? void 0 : _c.toString(), l5 = o3[c3.assetTypeId], y2 = (_d = l5 == null ? void 0 : l5.assetTypeCode) == null ? void 0 : _d.toString(), f3 = s6[a6], m3 = ((_e = o3[f3.networkSourceId]) == null ? void 0 : _e.layerId.toString()) ?? "", T2 = (_g = (_f = o3[f3.assetGroupId]) == null ? void 0 : _f.assetGroupCode) == null ? void 0 : _g.toString(), h2 = o3[f3.assetTypeId], v2 = (_h = h2 == null ? void 0 : h2.assetTypeCode) == null ? void 0 : _h.toString(), S = e4[p9] ?? { assetGroupHash: {} };
        if (!(d3 && y2 && T2 && v2))
          continue;
        const I = S.assetGroupHash[d3] ?? { assetTypeHash: {} }, g2 = I.assetTypeHash[y2] ?? {};
        if (g2[m3] = g2[m3] ?? {}, u4) {
          g2[p9] = g2[p9] ?? {};
          const e5 = `(assetgroup = ${d3} AND assettype = ${y2})`;
          g2[p9].anyVertex = g2[p9].anyVertex ? `${g2[p9].anyVertex}` : `${e5}`, "esriNECPEndVertex" === (h2 == null ? void 0 : h2.connectivityPolicy) && (g2[p9].endVertex = ((_i = g2[p9]) == null ? void 0 : _i.endVertex) ? `${g2[p9].endVertex}` : `${e5}`);
        }
        const x2 = `(assetgroup = ${T2} AND assettype = ${v2})`;
        g2[m3].anyVertex = ((_j = g2[m3]) == null ? void 0 : _j.anyVertex) ? `${g2[m3].anyVertex} OR ${x2}` : `${x2}`, "esriNECPEndVertex" === (h2 == null ? void 0 : h2.connectivityPolicy) && (g2[m3].endVertex = ((_k = g2[m3]) == null ? void 0 : _k.endVertex) ? `${g2[m3].endVertex} OR ${x2}` : `${x2}`), I.assetTypeHash[y2] = g2, S.assetGroupHash[d3] = I, e4[p9] = S;
      }
    }
    this.rulesHash = e4;
  }
};
e([y({ constructOnly: true })], a4.prototype, "layer", void 0), e([y({ constructOnly: true })], a4.prototype, "rules", void 0), e([y()], a4.prototype, "rulesHash", void 0), e([y({ constructOnly: true })], a4.prototype, "request", void 0), a4 = e([a("esri.networks.RulesTable")], a4);
var u3 = a4;

// node_modules/@arcgis/core/networks/support/NetworkSystemLayers.js
var e3 = class extends m {
  constructor(r2) {
    super(r2), this.rulesTableId = null, this.rulesTableUrl = null, this.subnetworksTableId = null, this.subnetworksTableUrl = null, this.dirtyAreasLayerId = null, this.dirtyAreasLayerUrl = null;
  }
};
e([y({ constructOnly: true })], e3.prototype, "rulesTableId", void 0), e([y({ constructOnly: true })], e3.prototype, "rulesTableUrl", void 0), e([y({ constructOnly: true })], e3.prototype, "subnetworksTableId", void 0), e([y({ constructOnly: true })], e3.prototype, "subnetworksTableUrl", void 0), e([y({ constructOnly: true })], e3.prototype, "dirtyAreasLayerId", void 0), e([y({ constructOnly: true })], e3.prototype, "dirtyAreasLayerUrl", void 0), e3 = e([a("esri.networks.support.NetworkSystemLayers")], e3);
var l4 = e3;

// node_modules/@arcgis/core/networks/support/Terminal.js
var s5 = class extends l {
  constructor(r2) {
    super(r2), this.id = null, this.name = null;
  }
};
e([y({ type: Number, json: { read: { source: "terminalId" }, write: { target: "terminalId" } } })], s5.prototype, "id", void 0), e([y({ type: String, json: { read: { source: "terminalName" }, write: { target: "terminalName" } } })], s5.prototype, "name", void 0), e([y({ type: Boolean, json: { write: true } })], s5.prototype, "isUpstreamTerminal", void 0), s5 = e([a("esri.networks.support.Terminal")], s5);
var p6 = s5;

// node_modules/@arcgis/core/networks/support/TerminalConfiguration.js
var a5 = new s3({ esriUNTMBidirectional: "bidirectional", esriUNTMDirectional: "directional" });
var n2 = class extends l {
  constructor(r2) {
    super(r2), this.defaultConfiguration = null, this.id = null, this.name = null, this.terminals = [], this.traversabilityModel = null;
  }
};
e([y({ type: String, json: { write: true } })], n2.prototype, "defaultConfiguration", void 0), e([y({ type: Number, json: { read: { source: "terminalConfigurationId" }, write: { target: "terminalConfigurationId" } } })], n2.prototype, "id", void 0), e([y({ type: String, json: { read: { source: "terminalConfigurationName" }, write: { target: "terminalConfigurationName" } } })], n2.prototype, "name", void 0), e([y({ type: [p6], json: { write: true } })], n2.prototype, "terminals", void 0), e([y({ type: a5.apiValues, json: { type: a5.jsonValues, read: a5.read, write: a5.write } })], n2.prototype, "traversabilityModel", void 0), n2 = e([a("esri.networks.support.TerminalConfiguration")], n2);
var p7 = n2;

// node_modules/@arcgis/core/networks/support/TraceJobInfo.js
var n3 = o()({ Pending: "job-waiting", InProgress: "job-executing", Completed: "job-succeeded" });
var p8 = class extends a2 {
  constructor(t4) {
    super(t4), this.statusUrl = null, this.status = null, this.submissionTime = null, this.lastUpdatedTime = null, this._timer = void 0;
  }
  destroy() {
    clearInterval(this._timer);
  }
  async checkJobStatus(t4) {
    const e4 = { ...t4, query: { f: "json" } }, { data: r2 } = await j(this.statusUrl, e4), o3 = r2.traceResults ? { ...r2.traceResults, ...r2 } : r2;
    return this.read(o3), this;
  }
  async waitForJobCompletion(t4 = {}) {
    const { interval: s6 = 1e3, statusCallback: e4 } = t4;
    return new Promise((t5, o3) => {
      this._clearTimer();
      const i2 = setInterval(() => {
        this._timer || o3(c()), this.checkJobStatus().then((s7) => {
          const { status: r2 } = s7;
          switch (this.status = r2, r2) {
            case "job-succeeded":
              this._clearTimer(), t5(this);
              break;
            case "job-waiting":
            case "job-executing":
              e4 && e4(this);
          }
        }, (t6) => {
          this._clearTimer(), o3(t6);
        });
      }, s6);
      this._timer = i2;
    });
  }
  _clearTimer() {
    clearInterval(this._timer), this._timer = void 0;
  }
};
e([y({ type: String, json: { write: true } })], p8.prototype, "statusUrl", void 0), e([o2(n3)], p8.prototype, "status", void 0), e([y({ type: Date, json: { type: Number, write: { writer: (t4, s6) => {
  s6.submissionTime = t4 ? t4.getTime() : null;
} } } })], p8.prototype, "submissionTime", void 0), e([y({ type: Date, json: { type: Number, write: { writer: (t4, s6) => {
  s6.lastUpdatedTime = t4 ? t4.getTime() : null;
} } } })], p8.prototype, "lastUpdatedTime", void 0), p8 = e([a("esri.networks.support.TraceJobInfo")], p8);
var m2 = p8;

// node_modules/@arcgis/core/networks/UtilityNetwork.js
var T = "esri.networks.UtilityNetwork";
var f2 = s.getLogger(T);
var b2 = class extends j2 {
  constructor(e4) {
    super(e4), this.sharedNamedTraceConfigurations = [], this.type = "utility";
  }
  get serviceTerritoryFeatureLayerId() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.serviceTerritoryFeatureLayerId) ?? null;
  }
  get networkSystemLayers() {
    var _a, _b, _c, _d, _e, _f;
    return new l4({ rulesTableId: (_a = this.sourceJSON) == null ? void 0 : _a.systemLayers.rulesTableId, rulesTableUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_b = this.sourceJSON) == null ? void 0 : _b.systemLayers.rulesTableId}` : null, subnetworksTableId: (_c = this.sourceJSON) == null ? void 0 : _c.systemLayers.subnetworksTableId, subnetworksTableUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_d = this.sourceJSON) == null ? void 0 : _d.systemLayers.subnetworksTableId}` : null, dirtyAreasLayerId: (_e = this.sourceJSON) == null ? void 0 : _e.systemLayers.dirtyAreasLayerId, dirtyAreasLayerUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_f = this.sourceJSON) == null ? void 0 : _f.systemLayers.dirtyAreasLayerId}` : null });
  }
  get rulesTableId() {
    var _a;
    return t(f2, "rulesTableId", { replacement: "networkSystemLayers.rulesTableId", version: "4.25" }), (_a = this.sourceJSON) == null ? void 0 : _a.systemLayers.rulesTableId;
  }
  get rulesTableUrl() {
    return t(f2, "rulesTableUrl", { replacement: "networkSystemLayers.rulesTableUrl", version: "4.25" }), this.sourceJSON ? `${this.featureServiceUrl}/${this.networkSystemLayers.rulesTableId}` : null;
  }
  get subnetworksTableId() {
    var _a;
    return t(f2, "subnetworksTableId", { replacement: "networkSystemLayers.subnetworksTableId", version: "4.25" }), (_a = this.sourceJSON) == null ? void 0 : _a.systemLayers.subnetworksTableId;
  }
  get subnetworksTableUrl() {
    return t(f2, "subnetworksTableUrl", { replacement: "networkSystemLayers.subnetworksTableUrl", version: "4.25" }), this.sourceJSON ? `${this.featureServiceUrl}/${this.networkSystemLayers.subnetworksTableId}` : null;
  }
  get terminalConfigurations() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.terminalConfigurations.map((e4) => p7.fromJSON(e4))) || [];
  }
  get domainNetworkNames() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.domainNetworks.map((e4) => e4.domainNetworkName)) || [];
  }
  get _utilityLayerList() {
    var _a, _b;
    const e4 = /* @__PURE__ */ new Set();
    return (_b = (_a = this.dataElement) == null ? void 0 : _a.domainNetworks) == null ? void 0 : _b.map((t4) => {
      t4.edgeSources.map((t5) => {
        e4.add(t5.layerId);
      }), t4.junctionSources.map((t5) => {
        e4.add(t5.layerId);
      });
    }), e4;
  }
  async load(e4) {
    return this.addResolvingPromise(super.load(e4)), this.addResolvingPromise(this._loadNamedTraceConfigurationsFromNetwork(e4)), this;
  }
  getTerminalConfiguration(e4) {
    var _a, _b, _c, _d;
    let t4 = null, r2 = null;
    const s6 = e4.layer;
    let a6 = null;
    if ("feature" === (s6 == null ? void 0 : s6.type)) {
      if (a6 = s6.layerId, null === a6)
        return null;
    } else {
      if ("subtype-sublayer" !== (s6 == null ? void 0 : s6.type))
        return null;
      if (a6 = ((_a = s6 == null ? void 0 : s6.parent) == null ? void 0 : _a.layerId) ?? null, null === a6)
        return null;
    }
    const o3 = e4.attributes;
    if (null == o3)
      return null;
    for (const l5 of Object.keys(o3))
      "ASSETGROUP" === l5.toUpperCase() && (t4 = e4.getAttribute(l5)), "ASSETTYPE" === l5.toUpperCase() && (r2 = e4.getAttribute(l5));
    if (!this.dataElement)
      return null;
    let n4 = null;
    const i2 = this.dataElement.domainNetworks;
    for (const l5 of i2) {
      const e5 = (_b = l5.junctionSources) == null ? void 0 : _b.find((e6) => e6.layerId === a6);
      if (e5) {
        const s7 = (_c = e5.assetGroups) == null ? void 0 : _c.find((e6) => e6.assetGroupCode === t4);
        if (s7) {
          const e6 = (_d = s7.assetTypes) == null ? void 0 : _d.find((e7) => e7.assetTypeCode === r2);
          if (e6) {
            n4 = e6.terminalConfigurationId;
            break;
          }
        }
      }
    }
    if (null != n4) {
      const e5 = this.dataElement.terminalConfigurations, t5 = e5 == null ? void 0 : e5.find((e6) => e6.terminalConfigurationId === n4);
      return t5 ? p7.fromJSON(t5) : null;
    }
    return null;
  }
  getTierNames(e4) {
    var _a;
    const t4 = (_a = this.dataElement) == null ? void 0 : _a.domainNetworks.find((t5) => t5.domainNetworkName === e4);
    return (t4 == null ? void 0 : t4.tiers.map((e5) => e5.name)) || [];
  }
  async getRulesTable() {
    return this._createRulesTable();
  }
  isUtilityLayer(e4) {
    return this._utilityLayerList.has(e4.layerId);
  }
  async trace(e4) {
    const [{ trace: t4 }, { default: r2 }] = await Promise.all([import("./trace-F5LMTXSD.js"), import("./TraceParameters-4IGNFUOB.js")]), s6 = r2.from(e4);
    return t4(this.networkServiceUrl, s6);
  }
  async submitTraceJob(e4) {
    const [{ submitTraceJob: t4 }, { default: r2 }] = await Promise.all([import("./trace-F5LMTXSD.js"), import("./TraceParameters-4IGNFUOB.js")]), s6 = r2.from(e4), a6 = await t4(this.networkServiceUrl, s6);
    return new m2({ statusUrl: a6 });
  }
  async _loadNamedTraceConfigurationsFromNetwork(e4) {
    var _a;
    if (0 === ((_a = this.sharedNamedTraceConfigurations) == null ? void 0 : _a.length))
      return;
    const t4 = this.sharedNamedTraceConfigurations.map((e5) => e5.globalId), r2 = await this.queryNamedTraceConfigurations({ globalIds: t4 }, e4);
    for (const s6 of this.sharedNamedTraceConfigurations) {
      const e5 = r2 == null ? void 0 : r2.find((e6) => e6.globalId === s6.globalId);
      if (e5) {
        const t5 = e5.write({}, { origin: "service" });
        s6.read(t5, { origin: "service" });
      }
    }
  }
  async _createRulesTable() {
    var _a;
    const e4 = new Be({ url: this.rulesTableUrl });
    await e4.load();
    const t4 = (_a = this.dataElement) == null ? void 0 : _a.domainNetworks;
    if (!t4)
      return null;
    const r2 = t4.flatMap((e5) => [...e5.edgeSources, ...e5.junctionSources]), s6 = (await this._queryRulesTable(e4)).map((t5) => this._hydrateRuleInfo(e4, r2, t5));
    return new u3({ layer: e4, rules: s6 });
  }
  async _queryRulesTable(e4) {
    const t4 = new b({ where: "1=1", outFields: ["*"] });
    return (await r(e4, t4)).features;
  }
  _hydrateRuleInfo(e4, t4, r2) {
    const s6 = e4.fieldsIndex, a6 = s6.get("RULETYPE"), o3 = s6.get("CREATIONDATE"), n4 = s6.get("FROMNETWORKSOURCEID"), i2 = s6.get("FROMASSETGROUP"), l5 = s6.get("FROMASSETTYPE"), u4 = s6.get("FROMTERMINALID"), m3 = s6.get("TONETWORKSOURCEID"), d3 = s6.get("TOASSETGROUP"), c3 = s6.get("TOASSETTYPE"), p9 = s6.get("TOTERMINALID"), T2 = s6.get("VIANETWORKSOURCEID"), f3 = s6.get("VIAASSETGROUP"), b3 = s6.get("VIAASSETTYPE"), g2 = s6.get("VIATERMINALID"), I = r2.attributes[a6.name], w = new Date(r2.attributes[o3.name]), S = [{ networkSourceId: r2.attributes[n4.name], assetGroupId: r2.attributes[i2.name], assetTypeId: r2.attributes[l5.name], terminalId: r2.attributes[u4.name] }, { networkSourceId: r2.attributes[m3.name], assetGroupId: r2.attributes[d3.name], assetTypeId: r2.attributes[c3.name], terminalId: r2.attributes[p9.name] }, { networkSourceId: r2.attributes[T2.name], assetGroupId: r2.attributes[f3.name], assetTypeId: r2.attributes[b3.name], terminalId: r2.attributes[g2.name] }];
    let h2;
    !function(e5) {
      e5[e5.from = 0] = "from", e5[e5.to = 1] = "to", e5[e5.via = 2] = "via";
    }(h2 || (h2 = {}));
    const k = { ruleType: I, creationDate: w };
    for (const N of [h2.from, h2.to, h2.via]) {
      if (I !== t2.RTEdgeJunctionEdgeConnectivity && N === h2.via)
        continue;
      const e5 = S[N], r3 = t4.find((t5) => t5.sourceId === e5.networkSourceId), s7 = r3 == null ? void 0 : r3.assetGroups.find((t5) => t5.assetGroupCode === e5.assetGroupId), a7 = s7 == null ? void 0 : s7.assetTypes.find((t5) => t5.assetTypeCode === e5.assetTypeId);
      let o4 = this._getTerminal(I, a7, e5);
      I !== t2.RTContainment && I !== t2.RTAttachment || (o4 = null);
      let n5 = "";
      switch (N) {
        case h2.from:
          n5 = "from";
          break;
        case h2.to:
          n5 = "to";
          break;
        case h2.via:
          n5 = "via";
      }
      k[`${n5}NetworkSource`] = r3, k[`${n5}AssetGroup`] = s7, k[`${n5}AssetType`] = a7, k[`${n5}Terminal`] = o4 == null ? void 0 : o4.toJSON();
    }
    return k;
  }
  _getTerminal(e4, t4, r2) {
    var _a, _b;
    if (e4 === t2.RTAttachment || e4 === t2.RTContainment)
      return null;
    const s6 = t4 == null ? void 0 : t4.terminalConfigurationId, a6 = (_a = this.terminalConfigurations) == null ? void 0 : _a.find((e5) => e5.id === s6);
    return ((_b = a6 == null ? void 0 : a6.terminals) == null ? void 0 : _b.find((e5) => e5.id === r2.terminalId)) ?? null;
  }
};
e([y({ type: [c2], json: { origins: { "web-map": { read: { source: "traceConfigurations" }, write: { target: "traceConfigurations" } }, service: { read: { source: "traceConfigurations" } } }, read: false } })], b2.prototype, "sharedNamedTraceConfigurations", void 0), e([y({ type: ["utility"], readOnly: true, json: { read: false, write: false } })], b2.prototype, "type", void 0), e([y({ readOnly: true })], b2.prototype, "serviceTerritoryFeatureLayerId", null), e([y({ readOnly: true })], b2.prototype, "networkSystemLayers", null), e([y({ readOnly: true })], b2.prototype, "rulesTableId", null), e([y({ readOnly: true })], b2.prototype, "rulesTableUrl", null), e([y({ readOnly: true })], b2.prototype, "subnetworksTableId", null), e([y({ readOnly: true })], b2.prototype, "subnetworksTableUrl", null), e([y({ readOnly: true })], b2.prototype, "terminalConfigurations", null), e([y({ readOnly: true })], b2.prototype, "domainNetworkNames", null), b2 = e([a("esri.networks.UtilityNetwork")], b2);
var g = b2;

export {
  g
};
//# sourceMappingURL=chunk-XYPRQK7D.js.map
