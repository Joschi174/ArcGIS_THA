import {
  E,
  a as a3,
  n as n2,
  o,
  x
} from "./chunk-CQ6LDXRQ.js";
import "./chunk-66V6VC6G.js";
import "./chunk-IOMDA26A.js";
import {
  i
} from "./chunk-3Q24STUY.js";
import "./chunk-PORVB4YW.js";
import "./chunk-6W4QNETY.js";
import "./chunk-SKZVSZDU.js";
import "./chunk-2QRPHNFJ.js";
import "./chunk-RHYB7TAK.js";
import "./chunk-L3YUDCKP.js";
import "./chunk-INPPJTIQ.js";
import {
  p as p2
} from "./chunk-6VFZXUIR.js";
import "./chunk-D7PFANSX.js";
import "./chunk-C6XOMDEV.js";
import "./chunk-BCTQLMHE.js";
import "./chunk-Z3XU4R74.js";
import {
  p
} from "./chunk-ZQ26W5UV.js";
import "./chunk-SGIIR6RJ.js";
import "./chunk-INNSNI53.js";
import "./chunk-5NQNQAAW.js";
import "./chunk-KEJOWWPH.js";
import "./chunk-IL355RAY.js";
import "./chunk-3V3OLLRL.js";
import {
  S
} from "./chunk-WD44CU6B.js";
import "./chunk-HXF46NPP.js";
import "./chunk-WD6NUK3A.js";
import "./chunk-KBZKT5PQ.js";
import "./chunk-OBYHRJUR.js";
import {
  a as a2,
  s as s2
} from "./chunk-L45WQWKV.js";
import "./chunk-EWJFH5BC.js";
import "./chunk-OYV6FNKL.js";
import "./chunk-5YQM3GC2.js";
import "./chunk-I3HK53BD.js";
import "./chunk-77MJECFF.js";
import "./chunk-CTZ7DCY5.js";
import "./chunk-QKOLWFRE.js";
import "./chunk-YM5PYJO5.js";
import "./chunk-KE5B3PMZ.js";
import "./chunk-2QUCKFNX.js";
import "./chunk-L2VQ7IPJ.js";
import "./chunk-K7U6HDB6.js";
import "./chunk-64B6H5RV.js";
import "./chunk-Z7ID6LQT.js";
import "./chunk-HP3XVAWO.js";
import "./chunk-OB7XGIVW.js";
import "./chunk-TOTT47W3.js";
import "./chunk-WYSOLO6F.js";
import "./chunk-DSRRGXQP.js";
import "./chunk-6WLIVBPN.js";
import "./chunk-WAWVWQWY.js";
import "./chunk-7XK4IPKN.js";
import "./chunk-3S6PFVBD.js";
import "./chunk-A7HIXRLM.js";
import "./chunk-HXG3EAGH.js";
import "./chunk-KZ7KT6JL.js";
import "./chunk-PSEOYXGU.js";
import "./chunk-PDYDTTO6.js";
import "./chunk-V65JFJHR.js";
import "./chunk-7P2S6N4H.js";
import "./chunk-6PE6O23W.js";
import "./chunk-BI26XH27.js";
import "./chunk-PPY3JRDD.js";
import "./chunk-Z3LDBFKX.js";
import "./chunk-Y4FK2QML.js";
import "./chunk-V2A2K5J6.js";
import "./chunk-VEIPKRDL.js";
import "./chunk-2T74GJVJ.js";
import "./chunk-6VWXQUWW.js";
import "./chunk-WNCSTS7O.js";
import "./chunk-JU2JBJRJ.js";
import "./chunk-CBBETCDS.js";
import "./chunk-D3IA7B5F.js";
import "./chunk-RKDN5PXO.js";
import "./chunk-UILB2BFY.js";
import "./chunk-U4PYQFWE.js";
import "./chunk-FNONMLXB.js";
import "./chunk-7KNADJUA.js";
import {
  f
} from "./chunk-NMXESCE4.js";
import "./chunk-O6HKLIZS.js";
import "./chunk-FQMVGWVJ.js";
import "./chunk-VXRBE6UP.js";
import "./chunk-YJ7LTVO5.js";
import "./chunk-OICH3FD6.js";
import "./chunk-DNUHV7J4.js";
import "./chunk-RRCNLKGG.js";
import "./chunk-RJHZ4FSH.js";
import "./chunk-DUGCD7YI.js";
import {
  a2 as a
} from "./chunk-3CMERT4A.js";
import {
  e
} from "./chunk-ZQWMLUHC.js";
import "./chunk-G5A25MBN.js";
import "./chunk-7LFT2RDJ.js";
import "./chunk-QPWNDO2C.js";
import "./chunk-CA2PXGXL.js";
import "./chunk-RXTTOJU7.js";
import {
  d,
  s
} from "./chunk-4HAMAX2C.js";
import {
  n,
  u
} from "./chunk-3QT5L2OK.js";
import "./chunk-5QASCMFT.js";
import "./chunk-GHZEFXB4.js";
import "./chunk-5G3YEFQP.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/2d/layers/features/support/ResourceManagerProxy.js
var t = class {
  constructor(e2) {
    this._remoteClient = e2, this._resourceMap = /* @__PURE__ */ new Map(), this._inFlightResourceMap = /* @__PURE__ */ new Map(), this.geometryEngine = null, this.geometryEnginePromise = null;
  }
  destroy() {
  }
  async fetchResource(t2, r) {
    const s3 = this._resourceMap, i2 = s3.get(t2);
    if (i2)
      return i2;
    let n3 = this._inFlightResourceMap.get(t2);
    if (n3)
      return n3;
    try {
      n3 = this._remoteClient.invoke("tileRenderer.fetchResource", { url: t2 }, { ...r }), this._inFlightResourceMap.set(t2, n3), n3.then((e2) => (this._inFlightResourceMap.delete(t2), s3.set(t2, e2), e2));
    } catch (o2) {
      return d(o2) ? null : { width: 0, height: 0 };
    }
    return n3;
  }
  getResource(e2) {
    return this._resourceMap.get(e2) ?? null;
  }
  loadFont(e2) {
    return Promise.resolve(null);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processors/SymbolProcessor.js
function b(e2, t2) {
  return (!e2.minScale || e2.minScale >= t2) && (!e2.maxScale || e2.maxScale <= t2);
}
function S2(e2) {
  const t2 = e2.message, r = { message: { data: {}, tileKey: t2.tileKey, tileKeyOrigin: t2.tileKeyOrigin, version: t2.version }, transferList: new Array() };
  for (const i2 in t2.data) {
    const e3 = i2, a4 = t2.data[e3];
    if (r.message.data[e3] = null, null != a4) {
      const t3 = a4.stride, i3 = a4.indices.slice(0), o2 = a4.vertices.slice(0), n3 = a4.records.slice(0), l = { stride: t3, indices: i3, vertices: o2, records: n3, metrics: n(a4.metrics, (e4) => e4.slice(0)) };
      r.transferList.push(i3, o2, n3), r.message.data[e3] = l;
    }
  }
  return r;
}
var w = class extends p {
  constructor() {
    super(...arguments), this.type = "symbol", this._matchers = { feature: null, aggregate: null }, this._bufferData = /* @__PURE__ */ new Map(), this._bufferIds = /* @__PURE__ */ new Map();
  }
  initialize() {
    this.handles.add([this.tileStore.on("update", this.onTileUpdate.bind(this))]), this._resourceManagerProxy = new t(this.remoteClient);
  }
  destroy() {
    this._resourceManagerProxy.destroy();
  }
  get supportsTileUpdates() {
    return true;
  }
  forEachBufferId(e2) {
    this._bufferIds.forEach((t2) => {
      t2.forEach(e2);
    });
  }
  async update(e2, t2) {
    var _a;
    const s3 = t2.schema.processors[0];
    if ("symbol" !== s3.type)
      return;
    const r = a2(this._schema, s3);
    (s2(r, "mesh") || s2(r, "target")) && (e2.mesh = true, (_a = e2.why) == null ? void 0 : _a.mesh.push("Symbology changed"), this._schema = s3, this._factory = this._createFactory(s3), this._factory.update(s3, this.tileStore.tileScheme.tileInfo));
  }
  onTileMessage(e2, t2, s3, r) {
    return s(r), this._onTileData(e2, t2, s3, r);
  }
  onTileClear(e2, t2) {
    const s3 = { clear: true, end: t2 };
    return this._bufferData.delete(e2.key.id), this._bufferIds.delete(e2.key.id), this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e2.id, data: s3 });
  }
  onTileError(e2, t2, s3) {
    const r = s3.signal, i2 = { tileKey: e2.id, error: t2 };
    return this.remoteClient.invoke("tileRenderer.onTileError", i2, { signal: r });
  }
  onTileUpdate(e2) {
    for (const t2 of e2.removed)
      this._bufferData.has(t2.key.id) && this._bufferData.delete(t2.key.id), this._bufferIds.has(t2.key.id) && this._bufferIds.delete(t2.key.id);
    for (const t2 of e2.added)
      this._bufferData.forEach((e3) => {
        for (const s3 of e3)
          s3.message.tileKey === t2.id && this._updateTileMesh("append", t2, S2(s3), [], false, false, null);
      });
  }
  _addBufferData(e2, t2) {
    var _a;
    this._bufferData.has(e2) || this._bufferData.set(e2, []), (_a = this._bufferData.get(e2)) == null ? void 0 : _a.push(S2(t2));
  }
  _createFactory(e2) {
    const { geometryType: t2, objectIdField: r, fields: i2 } = this.service, a4 = (e3, t3) => this.remoteClient.invoke("tileRenderer.getMaterialItems", e3, t3), o2 = { geometryType: t2, fields: i2, spatialReference: f.fromJSON(this.spatialReference) }, n3 = new x(a4, this.tileStore.tileScheme.tileInfo), { matcher: l, aggregateMatcher: d2 } = e2.mesh;
    return this._store = n3, this._matchers.feature = o(l, n3, o2, this._resourceManagerProxy), this._matchers.aggregate = n(d2, (e3) => o(e3, n3, o2, this._resourceManagerProxy)), new a3(t2, r, n3);
  }
  async _onTileData(e2, t2, s3, r) {
    var _a;
    s(r);
    const { type: a4, addOrUpdate: o2, remove: n3, clear: l, end: c } = t2, d2 = !!this._schema.mesh.sortKey;
    if (!o2) {
      const t3 = { type: a4, addOrUpdate: null, remove: n3, clear: l, end: c, sort: d2 };
      return this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e2.id, data: t3 }, r);
    }
    const h = this._processFeatures(e2, o2, s3, r, (_a = t2.status) == null ? void 0 : _a.version);
    try {
      const s4 = await h;
      if (null == s4) {
        const t3 = { type: a4, addOrUpdate: null, remove: n3, clear: l, end: c, sort: d2 };
        return this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e2.id, data: t3 }, r);
      }
      const i2 = [];
      for (const t3 of s4) {
        let s5 = false;
        const r2 = t3.message.bufferIds, a5 = e2.key.id, o3 = t3.message.tileKey;
        if (a5 !== o3 && null != r2) {
          if (!this.tileStore.get(o3)) {
            this._addBufferData(a5, t3), i2.push(t3);
            continue;
          }
          let e3 = this._bufferIds.get(o3);
          e3 || (e3 = /* @__PURE__ */ new Set(), this._bufferIds.set(o3, e3));
          const n4 = Array.from(r2);
          for (const t4 of n4) {
            if (e3.has(t4)) {
              s5 = true;
              break;
            }
            e3.add(t4);
          }
        }
        s5 || (this._addBufferData(a5, t3), i2.push(t3));
      }
      await Promise.all(i2.map((s5) => {
        const i3 = e2.key.id === s5.message.tileKey, o3 = i3 ? t2.remove : [], n4 = i3 && t2.end;
        return this._updateTileMesh(a4, e2, s5, o3, n4, !!t2.clear, r.signal);
      }));
    } catch (f2) {
      this._handleError(e2, f2, r);
    }
  }
  async _updateTileMesh(e2, t2, r, a4, o2, n3, l) {
    const c = e2, d2 = r.message.tileKey, h = !!this._schema.mesh.sortKey;
    d2 !== t2.key.id && (o2 = false);
    const f2 = { type: c, addOrUpdate: n(r, (e3) => e3.message), remove: a4, clear: n3, end: o2, sort: h }, u2 = { transferList: n(r, (e3) => e3.transferList) || [], signal: l };
    return s(u2), this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: d2, data: f2 }, u2);
  }
  async _processFeatures(e2, t2, s3, r, a4) {
    if (null == t2 || !t2.hasFeatures)
      return null;
    const o2 = { transform: e2.transform, hasZ: false, hasM: false }, n3 = this._factory, l = { viewingMode: "", scale: e2.scale }, c = await this._matchers.feature, d2 = await this._matchers.aggregate;
    s(r);
    const h = this._getLabelInfos(e2, t2);
    return await n3.analyze(t2.getCursor(), this._resourceManagerProxy, c, d2, o2, l), s(r), this._writeFeatureSet(e2, t2, o2, h, n3, s3, a4);
  }
  _writeFeatureSet(e2, t2, s3, r, i2, a4, o2) {
    const n3 = t2.getSize(), l = this._schema.mesh.matcher.symbologyType, c = new E(e2.key.id, { features: n3, records: n3, metrics: 0 }, l, a4, l !== S.HEATMAP, o2), d2 = { viewingMode: "", scale: e2.scale }, u2 = t2.getCursor();
    for (; u2.next(); )
      try {
        const t3 = u2.getDisplayId(), a5 = null != r ? r.get(t3) : null;
        i2.writeCursor(c, u2, s3, d2, e2.level, a5, this._resourceManagerProxy);
      } catch (g) {
      }
    const m = e2.tileInfoView.tileInfo.isWrappable;
    return c.serialize(m);
  }
  _handleError(e2, t2, s3) {
    if (!d(t2)) {
      const r = { tileKey: e2.id, error: t2.message };
      return this.remoteClient.invoke("tileRenderer.onTileError", r, { signal: s3.signal });
    }
    return Promise.resolve();
  }
  _getLabelingSchemaForScale(e2) {
    const t2 = this._schema.mesh.labels;
    if (null == t2)
      return null;
    if ("subtype" === t2.type) {
      const s4 = { type: "subtype", classes: {} };
      let r = false;
      for (const i2 in t2.classes) {
        const a4 = t2.classes[i2].filter((t3) => b(t3, e2.scale));
        r = r || !!a4.length, s4.classes[i2] = a4;
      }
      return r ? s4 : null;
    }
    const s3 = t2.classes.filter((t3) => b(t3, e2.scale));
    return s3.length ? { type: "simple", classes: s3 } : null;
  }
  _getLabels(e2, t2) {
    if ("subtype" === t2.type) {
      const s3 = this.service.subtypeField, i2 = u(s3, "Expected to find subtype Field"), a4 = e2.readAttribute(i2);
      return null == a4 ? [] : t2.classes[a4] ?? [];
    }
    return t2.classes;
  }
  _getLabelInfos(e2, s3) {
    const r = this._getLabelingSchemaForScale(e2);
    if (null == r)
      return null;
    const i2 = /* @__PURE__ */ new Map(), a4 = s3.getCursor();
    for (; a4.next(); ) {
      const e3 = a4.getDisplayId(), s4 = [], o2 = p2(e3), n3 = o2 && 1 !== a4.readAttribute("cluster_count") ? "aggregate" : "feature", l = this._getLabels(a4, r);
      for (const r2 of l) {
        if (r2.target !== n3)
          continue;
        const i3 = a4.getStorage(), l2 = o2 && "feature" === n3 ? i3.getComputedStringAtIndex(a4.readAttribute("referenceId"), r2.fieldIndex) : i3.getComputedStringAtIndex(e3, r2.fieldIndex);
        if (!l2)
          continue;
        const c = i(l2.toString()), d2 = c[0], h = c[1];
        this._store.getMosaicItem(r2.symbol, n2(d2)).then((e4) => {
          s4[r2.index] = { glyphs: e4.glyphMosaicItems ?? [], rtl: h, index: r2.index };
        });
      }
      i2.set(e3, s4);
    }
    return i2;
  }
};
w = e([a("esri.views.2d.layers.features.processors.SymbolProcessor")], w);
var I = w;
export {
  I as default
};
//# sourceMappingURL=SymbolProcessor-NWUAFG4Z.js.map
